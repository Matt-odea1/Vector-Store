{
  "attempt_id": null,
  "attempted_at": null,
  "attempts": null,
  "attempts_remaining": null,
  "available_at": null,
  "clean_attempts": false,
  "course_id": 16645,
  "created_at": "2024-05-27T01:25:35.951175+10:00",
  "due_at": null,
  "effective_available_at": null,
  "effective_due_at": null,
  "effective_locked_at": null,
  "first_viewed_at": null,
  "grade_passback_auto_send": false,
  "grade_passback_mode": "",
  "grade_passback_scale_to": null,
  "id": 53291,
  "index": 1,
  "inverse_regex": false,
  "is_hidden": false,
  "is_timed": false,
  "is_unlisted": false,
  "kind": "content",
  "last_viewed_slide_id": null,
  "late_submissions": true,
  "locked_at": null,
  "module_id": 11527,
  "number": -1,
  "openable": false,
  "openable_without_attempt": false,
  "original_id": 47883,
  "outline": "",
  "password": "",
  "password_one_time": false,
  "prerequisites": [],
  "release_challenge_solutions": false,
  "release_challenge_solutions_while_active": false,
  "release_feedback": false,
  "release_feedback_while_active": false,
  "release_quiz_correctness_only": false,
  "release_quiz_solutions": false,
  "reopen_submissions": false,
  "require_user_override": false,
  "settings": {
    "quiz_question_number_style": "",
    "quiz_mode": "multiple-attempts",
    "quiz_active_status": "active"
  },
  "slide_count": 8,
  "slide_marks_summary": [
    {
      "id": 361896,
      "is_hidden": false,
      "rubric_points": 0,
      "auto_points": 0,
      "scoring_mode": "",
      "scale_to": null,
      "scale_to_auto": null,
      "scale_to_rubric": null
    },
    {
      "id": 361897,
      "is_hidden": false,
      "rubric_points": 0,
      "auto_points": 0,
      "scoring_mode": "",
      "scale_to": null,
      "scale_to_auto": null,
      "scale_to_rubric": null
    },
    {
      "id": 361898,
      "is_hidden": false,
      "rubric_points": 0,
      "auto_points": 0,
      "scoring_mode": "",
      "scale_to": null,
      "scale_to_auto": null,
      "scale_to_rubric": null
    },
    {
      "id": 361899,
      "is_hidden": false,
      "rubric_points": 0,
      "auto_points": 0,
      "scoring_mode": "",
      "scale_to": null,
      "scale_to_auto": null,
      "scale_to_rubric": null
    },
    {
      "id": 361900,
      "is_hidden": false,
      "rubric_points": 0,
      "auto_points": 0,
      "scoring_mode": "",
      "scale_to": null,
      "scale_to_auto": null,
      "scale_to_rubric": null
    },
    {
      "id": 361901,
      "is_hidden": false,
      "rubric_points": 0,
      "auto_points": 0,
      "scoring_mode": "",
      "scale_to": null,
      "scale_to_auto": null,
      "scale_to_rubric": null
    },
    {
      "id": 361902,
      "is_hidden": false,
      "rubric_points": 0,
      "auto_points": 0,
      "scoring_mode": "",
      "scale_to": null,
      "scale_to_auto": null,
      "scale_to_rubric": null
    },
    {
      "id": 361903,
      "is_hidden": false,
      "rubric_points": 0,
      "auto_points": 0,
      "scoring_mode": "",
      "scale_to": null,
      "scale_to_auto": null,
      "scale_to_rubric": null
    }
  ],
  "slides": [
    {
      "id": 361896,
      "original_id": 326057,
      "lesson_id": 53291,
      "user_id": 93339,
      "course_id": 16645,
      "type": "document",
      "title": "1. Meet Karel",
      "index": 1,
      "is_hidden": false,
      "lesson_markable_id": null,
      "rubric_id": null,
      "rubric_points": null,
      "auto_points": null,
      "status": "unseen",
      "correct": null,
      "response": null,
      "created_at": "2024-05-27T01:25:35.951175+10:00",
      "updated_at": null,
      "content": "<document version=\"2.0\"><paragraph>In the 1970s, a Stanford graduate student, Rich Pattis decided that it would be easier to teach the fundamentals of programming if students could somehow learn the basic ideas in a simple environment free from the complexities that characterize most programming languages. Rich designed an introductory programming environment in which students teach a robot to solve simple problems. That robot was named Karel, after the Czech playwright <link href=\"https://en.wikipedia.org/wiki/Karel_%C4%8Capek\">Karel Čapek</link>, whose 1923 play R.U.R. (<link href=\"https://en.wikipedia.org/wiki/R.U.R.\">Rossum’s Universal Robots</link>) gave the word robot to the English language.</paragraph><paragraph>Karel the Robot was quite a success. Karel has been used in introductory computer science courses all across the world and has been taught to millions of students. Many generations of students have learned how programming works with Karel, and it is still the gentle introduction to coding used at Stanford.</paragraph><heading level=\"2\">What is Karel?</heading><paragraph>Karel is a very simple robot living in a very simple world. By giving Karel a set of commands, you can direct it to perform certain tasks within its world. The process of specifying those commands is called <bold>programming</bold>. Initially, Karel understands only a very small number of predefined commands, but an important part of the programming process is teaching Karel new commands that extend its capabilities.</paragraph><paragraph>Karel programs have much the same structure and involve the same fundamental elements as <link href=\"https://en.wikipedia.org/wiki/Python_(programming_language)\">Python</link>, a major <link href=\"https://en.wikipedia.org/wiki/Programming_language\">programming language</link>. The critical difference is that Karel’s programming language is extremely small and as such the details are easy to master. Even so, you will discover that solving a problem can be challenging.</paragraph><paragraph>By starting with Karel, you can concentrate on solving problems from the very beginning. Problem solving is the essence of programming. And because Karel encourages imagination and creativity, you can have quite a lot of fun along the way.</paragraph><snippet language=\"karel\" runnable=\"true\" line-numbers=\"true\"><snippet-file id=\"code\">def main():\n    move() \n    for c in range(4):\n        put_beeper()\n        move()\n\n    for c in range(3):\n        while front_is_clear():\n            move()\n            put_beeper()\n        turn_left()\n        move()\n</snippet-file><snippet-file id=\"karel-world\" initial-speed-idx=\"3\">{&#34;width&#34;:6,&#34;height&#34;:4,&#34;initialX&#34;:0,&#34;initialY&#34;:0,&#34;initialD&#34;:1,&#34;initialB&#34;:1000,&#34;cells&#34;:[]}</snippet-file></snippet><heading level=\"2\">Karel’s world</heading><paragraph>Karel’s world is defined by rows running horizontally (east-west) and columns running vertically (north-south). The intersection of a row and a column is called a corner. Karel can only be positioned on corners and must be facing one of the four standard compass directions (north, south, east, west). A sample Karel world is shown below. Here Karel is located at the corner of 1st row and 1st column, facing east.</paragraph><figure><image width=\"253\" height=\"176\" src=\"https://static.edusercontent.com/files/V2IAjqHcT1jbUD2cYWcC1kUc\"></image></figure><paragraph>Several other components of Karel’s world can be seen in this example. The object in front of Karel is a beeper. As described in Rich Pattis’s book, beepers are “plastic cones which emit a quiet beeping noise.” Karel can only detect a beeper if it is on the same corner. The solid lines in the diagram are walls. Walls serve as barriers within Karel’s world. Karel cannot walk through walls and must instead go around them. Karel’s world is always bounded by walls along the edges, but the world may have different dimensions depending on the specific problem Karel needs to solve.</paragraph><heading level=\"2\">Karel&#39;s commands</heading><paragraph>When Karel is shipped from the factory, it responds to a very small set of commands.</paragraph><web-snippet layout=\"seamless\" preview-hidden=\"true\"><web-snippet-file language=\"html\" hidden=\"true\">&lt;link rel=&#34;stylesheet&#34; href=&#34;https://unpkg.com/purecss@2.0.3/build/pure-min.css&#34; integrity=&#34;sha384-cg6SkqEOCV1NbJoCu11+bm0NvBRc8IYLRGXkmNrqUBfTjmMYwNKPWBTIKyw9mHNJ&#34; crossorigin=&#34;anonymous&#34;&gt;\n&lt;table class=&#34;pure-table&#34;&gt;\n  &lt;thead&gt;\n    &lt;tr&gt;&lt;th&gt;Command&lt;/th&gt;&lt;th&gt;Description&lt;/th&gt;&lt;/tr&gt;\n  &lt;/thead&gt;\n  &lt;tbody&gt;\n    &lt;tr&gt;&lt;td&gt;&lt;code&gt;move()&lt;/code&gt;&lt;/td&gt;&lt;td&gt;Asks Karel to move forward one block. Karel cannot respond to a &lt;code&gt;move()&lt;/code&gt; command if there is a wall blocking its way.&lt;/td&gt;&lt;/tr&gt;\n    &lt;tr&gt;&lt;td&gt;&lt;code&gt;turn_left()&lt;/code&gt;&lt;/td&gt;&lt;td&gt;Asks Karel to rotate 90 degrees to the left (counterclockwise).&lt;/td&gt;&lt;/tr&gt;\n    &lt;tr&gt;&lt;td&gt;&lt;code&gt;pick_beeper()&lt;/code&gt;&lt;/td&gt;&lt;td&gt;Asks Karel to pick up one beeper from a corner and stores the beeper in its beeper bag, which can hold an infinite number of beepers. Karel cannot respond to a &lt;code&gt;pick_beeper()&lt;/code&gt; command unless there is a beeper on the current corner.&lt;/td&gt;&lt;/tr&gt;\n    &lt;tr&gt;&lt;td&gt;&lt;code&gt;put_beeper()&lt;/code&gt;&lt;/td&gt;&lt;td&gt;Asks Karel to take a beeper from its beeper bag and put it down on the current corner. Karel cannot respond to a &lt;code&gt;put_beeper()&lt;/code&gt; command unless there are beepers in its beeper bag.&lt;/td&gt;&lt;/tr&gt;\n  &lt;/tbody&gt;\n&lt;/table&gt;</web-snippet-file><web-snippet-file language=\"css\" hidden=\"true\"></web-snippet-file><web-snippet-file language=\"js\" hidden=\"true\"></web-snippet-file></web-snippet><paragraph>The empty pair of parentheses that appears in each of these commands is part of the common syntax shared by Karel and Python and is used to specify the invocation of the command. Eventually, the programs you write will include additional information in the space between the parentheses, but such information is not part of the Karel’s primitive world. These parentheses will therefore be empty in standard Karel programs, but you must remember to include them nonetheless.</paragraph><paragraph>If Karel tries to do something illegal, such as moving through a wall or picking up a nonexistent beeper, an error condition occurs.</paragraph><paragraph>Karel’s commands, are not executed on their own. Instead, you need to incorporate them into a Karel program. You will have a chance to see a few simple Karel programs in Chapter 2!</paragraph><paragraph></paragraph><paragraph><break></break>Based on work by Chris Piech and Eric Roberts at Stanford University.<break></break><link href=\"https://compedu.stanford.edu/karel-reader/docs/python/en/intro.html\">https://compedu.stanford.edu/karel-reader/docs/python/en/intro.html</link></paragraph></document>"
    },
    {
      "id": 361897,
      "original_id": 326058,
      "lesson_id": 53291,
      "user_id": 93339,
      "course_id": 16645,
      "type": "document",
      "title": "2. Programming Karel",
      "index": 2,
      "is_hidden": false,
      "lesson_markable_id": null,
      "rubric_id": null,
      "rubric_points": null,
      "auto_points": null,
      "status": "unseen",
      "correct": null,
      "response": null,
      "created_at": "2024-05-27T01:25:35.951175+10:00",
      "updated_at": null,
      "content": "<document version=\"2.0\"><paragraph>The simplest style of Karel program uses text to specify a sequence of built-in commands that should be executed when the program is <bold>run</bold>. Consider the simple Karel program below. The text on the left is the program. The state of Karel&#39;s world is shown on the right:</paragraph><snippet language=\"karel\" runnable=\"true\" line-numbers=\"true\"><snippet-file id=\"code\"># Program: FirstKarel\n# -----------------------------\n# The FirstKarel program defines a &#34;main&#34; function\n# with three commands. These commands cause Karel\n# to move forward one block, pick up a beeper and\n# then move ahead to the next corner.\n\nfrom karel.stanfordkarel import *\n\ndef main():\n    move()\n    pick_beeper()\n    move()</snippet-file><snippet-file id=\"karel-world\" initial-speed-idx=\"\">{&#34;width&#34;:6,&#34;height&#34;:4,&#34;initialX&#34;:0,&#34;initialY&#34;:0,&#34;initialD&#34;:1,&#34;initialB&#34;:1000,&#34;cells&#34;:[{&#34;x&#34;:1,&#34;y&#34;:0,&#34;wall&#34;:{&#34;0&#34;:false,&#34;1&#34;:false,&#34;2&#34;:false,&#34;3&#34;:false},&#34;beepers&#34;:1,&#34;colour&#34;:&#34;BLANK&#34;},{&#34;x&#34;:2,&#34;y&#34;:0,&#34;wall&#34;:{&#34;0&#34;:false,&#34;1&#34;:true,&#34;2&#34;:false,&#34;3&#34;:false},&#34;beepers&#34;:0,&#34;colour&#34;:&#34;BLANK&#34;},{&#34;x&#34;:3,&#34;y&#34;:0,&#34;wall&#34;:{&#34;0&#34;:true,&#34;1&#34;:false,&#34;2&#34;:false,&#34;3&#34;:true},&#34;beepers&#34;:0,&#34;colour&#34;:&#34;BLANK&#34;},{&#34;x&#34;:4,&#34;y&#34;:0,&#34;wall&#34;:{&#34;0&#34;:true,&#34;1&#34;:false,&#34;2&#34;:false,&#34;3&#34;:false},&#34;beepers&#34;:0,&#34;colour&#34;:&#34;BLANK&#34;},{&#34;x&#34;:5,&#34;y&#34;:0,&#34;wall&#34;:{&#34;0&#34;:true,&#34;1&#34;:false,&#34;2&#34;:false,&#34;3&#34;:false},&#34;beepers&#34;:0,&#34;colour&#34;:&#34;BLANK&#34;},{&#34;x&#34;:3,&#34;y&#34;:1,&#34;wall&#34;:{&#34;0&#34;:false,&#34;1&#34;:false,&#34;2&#34;:true,&#34;3&#34;:false},&#34;beepers&#34;:0,&#34;colour&#34;:&#34;BLANK&#34;},{&#34;x&#34;:4,&#34;y&#34;:1,&#34;wall&#34;:{&#34;0&#34;:false,&#34;1&#34;:false,&#34;2&#34;:true,&#34;3&#34;:false},&#34;beepers&#34;:0,&#34;colour&#34;:&#34;BLANK&#34;},{&#34;x&#34;:5,&#34;y&#34;:1,&#34;wall&#34;:{&#34;0&#34;:false,&#34;1&#34;:false,&#34;2&#34;:true,&#34;3&#34;:false},&#34;beepers&#34;:0,&#34;colour&#34;:&#34;BLANK&#34;}]}</snippet-file></snippet><paragraph>Press the &#34;Run&#34; button to execute the program. Programs are typically written in a text editor or a special application called an IDE. This reader has the ability to execute programs in order to help you <italic>see</italic> how things work as you learn.</paragraph><paragraph>The program is composed of several parts. The first part consists of the following lines:</paragraph><pre># Program: FirstKarel\n# -----------------------------\n# The FirstKarel program defines a &#34;main&#34; function\n# with three commands. These commands cause Karel\n# to move forward one block, pick up a beeper\n# and then move ahead to the next corner.\n</pre><paragraph>These lines are an example of a <bold>comment</bold>, which is simply text designed to explain the operation of the program to human readers. Comments in both Karel and Python begin with the characters <code>#</code> and include the rest of the line. In a simple program, extensive comments may seem silly because the effect of the program is obvious, but they are extremely important as a means of documenting the design of larger, more complex programs. The second part of the program is the line:</paragraph><pre>from karel.stanford import *\n</pre><paragraph>This line requests the inclusion of all definitions from the <code>karel.stanford</code> library. This library contains the basic definitions necessary for writing Karel programs, such as the definitions of the standard operations <code>move()</code> and <code>pick_beeper()</code>. Because you always need access to these operations, every Karel program you write will include this import command before you write the actual program.</paragraph><paragraph>The final part of the Karel program consists of the following function definition:</paragraph><pre>def main():\n    move()\n    pick_beeper()\n    move()\n</pre><paragraph>These lines represent the definition of a new <bold>function</bold>, which specifies the sequence of steps necessary to respond to a command. As in the case of the FirstKarel program itself, the function definition consists of two parts that can be considered separately: The first line constitutes the function header and the indented code following is the function body. If you ignore the body for now, the function definition looks like this:</paragraph><pre>def main():\n    body of the function definition\n</pre><paragraph>The first word in the function header, <code>def</code>, is part of Python&#39;s syntactic structure. It says that you are creating a new function. The next word on the header line specifies the name of the new function, which in this case is <bold>main</bold>. Defining a function means that Karel can now respond to a new command with that name. The <code>main()</code> command plays a special role in a Karel program. When you start a Karel program it creates a new Karel instance, adds that Karel to a world that you specify, and then issues the <code>main()</code> command. The effect of running the program is defined by the body of the <code>main()</code> function, which is a sequence of commands that the robot will execute in order. For example, the body of the <code>main()</code> function for the <code>FirstKarel</code> program is:</paragraph><pre>    move()\n    pick_beeper()\n    move()\n</pre><paragraph>Thus, if the initial state of the world matches the example given in Chapter 1, Karel first moves forward into the corner containing the beeper, picks up that beeper, and finally moves forward to the corner just before the wall.</paragraph><heading level=\"2\">Solving a more interesting problem</heading><paragraph>The FirstKarel program defined above doesn’t do very much as yet. Let’s try to make it a little more interesting. Suppose that the goal is not simply to get Karel to pick up the beeper but to move the beeper from its initial position on 2nd column and 1st row to the center of a ledge. Thus, your next assignment is to define a new Karel program that accomplishes the task illustrated in this diagram:</paragraph><figure><image src=\"https://static.ap.edusercontent.com/files/yn5zK3NnI3gGvBoLqdP2xG2N\" width=\"292\" height=\"210\"></image></figure><paragraph>The first three commands in the new program—the ones that move forward, pick up the beeper, and then move up to the ledge—are the same as before:</paragraph><pre>    move()\n    pick_beeper()\n    move()</pre><paragraph>From here, the next step is to turn left to begin climbing the ledge. That operation is easy, because Karel has a <code>turn_left()</code> command in its standard repertoire. Executing a <code>turn_left()</code> command at the end of the preceding sequence of commands leaves Karel facing north on the corner of 1st row and 3rd column. If Karel then executes a <code>move()</code> command, it will move north to reach the following position:</paragraph><figure><image src=\"https://static.ap.edusercontent.com/files/vaDmenl7nbKG6PDXft8TEPNp\" width=\"297\" height=\"209\"></image></figure><paragraph>From here, the next thing you need to do is get Karel to turn right so that it is again facing east. While this operation is conceptually just as easy as getting Karel to turn left, there is a slight problem: Karel’s language includes a <code>turn_left()</code> command, but no <code>turn_right()</code> command. It’s as if you bought the economy model and have now discovered that it is missing some important features.</paragraph><paragraph>At this point, you have your first opportunity to begin thinking like a programmer. You have one set of commands, but not exactly the set you need. What can you do? Can you accomplish the effect of a <code>turn_right()</code> command using only the capabilities you have? The answer, of course, is yes. You can accomplish the effect of turning right by turning left three times. After three left turns, Karel will be facing in the desired direction. From here, all you need to do is program Karel to move over to the center of the ledge, drop the beeper and then move forward to the final position. Here is a complete implementation of a program that accomplishes the entire task:</paragraph><snippet language=\"karel\" runnable=\"true\" line-numbers=\"true\"><snippet-file id=\"code\"># Program: FirstKarel\n# -----------------------------\n# The FirstKarel program defines a &#34;main&#34; function\n# with commands that cause Karel to pick up\n# a beeper and place it on a ledge.\n\nfrom karel.stanfordkarel import *\n\ndef main():\n    move()\n    pick_beeper()\n    move()\n    turn_left()\n    move()\n    turn_left()\n    turn_left()\n    turn_left()\n    move()\n    move()\n    put_beeper()\n    move()</snippet-file><snippet-file id=\"karel-world\" initial-speed-idx=\"3\">{&#34;width&#34;:6,&#34;height&#34;:4,&#34;initialX&#34;:0,&#34;initialY&#34;:0,&#34;initialD&#34;:1,&#34;initialB&#34;:1000,&#34;cells&#34;:[{&#34;x&#34;:1,&#34;y&#34;:0,&#34;wall&#34;:{&#34;0&#34;:false,&#34;1&#34;:false,&#34;2&#34;:false,&#34;3&#34;:false},&#34;beepers&#34;:1,&#34;colour&#34;:&#34;BLANK&#34;},{&#34;x&#34;:2,&#34;y&#34;:0,&#34;wall&#34;:{&#34;0&#34;:false,&#34;1&#34;:true,&#34;2&#34;:false,&#34;3&#34;:false},&#34;beepers&#34;:0,&#34;colour&#34;:&#34;BLANK&#34;},{&#34;x&#34;:3,&#34;y&#34;:0,&#34;wall&#34;:{&#34;0&#34;:true,&#34;1&#34;:false,&#34;2&#34;:false,&#34;3&#34;:true},&#34;beepers&#34;:0,&#34;colour&#34;:&#34;BLANK&#34;},{&#34;x&#34;:4,&#34;y&#34;:0,&#34;wall&#34;:{&#34;0&#34;:true,&#34;1&#34;:false,&#34;2&#34;:false,&#34;3&#34;:false},&#34;beepers&#34;:0,&#34;colour&#34;:&#34;BLANK&#34;},{&#34;x&#34;:5,&#34;y&#34;:0,&#34;wall&#34;:{&#34;0&#34;:true,&#34;1&#34;:false,&#34;2&#34;:false,&#34;3&#34;:false},&#34;beepers&#34;:0,&#34;colour&#34;:&#34;BLANK&#34;},{&#34;x&#34;:3,&#34;y&#34;:1,&#34;wall&#34;:{&#34;0&#34;:false,&#34;1&#34;:false,&#34;2&#34;:true,&#34;3&#34;:false},&#34;beepers&#34;:0,&#34;colour&#34;:&#34;BLANK&#34;},{&#34;x&#34;:4,&#34;y&#34;:1,&#34;wall&#34;:{&#34;0&#34;:false,&#34;1&#34;:false,&#34;2&#34;:true,&#34;3&#34;:false},&#34;beepers&#34;:0,&#34;colour&#34;:&#34;BLANK&#34;},{&#34;x&#34;:5,&#34;y&#34;:1,&#34;wall&#34;:{&#34;0&#34;:false,&#34;1&#34;:false,&#34;2&#34;:true,&#34;3&#34;:false},&#34;beepers&#34;:0,&#34;colour&#34;:&#34;BLANK&#34;}]}</snippet-file></snippet><paragraph></paragraph><paragraph><break></break>Based on work by Chris Piech and Eric Roberts at Stanford University.<break></break><link href=\"https://compedu.stanford.edu/karel-reader/docs/python/en/intro.html\">https://compedu.stanford.edu/karel-reader/docs/python/en/intro.html</link></paragraph></document>"
    },
    {
      "id": 361898,
      "original_id": 326059,
      "lesson_id": 53291,
      "user_id": 93339,
      "course_id": 16645,
      "type": "document",
      "title": "3. Defining New Functions",
      "index": 3,
      "is_hidden": false,
      "lesson_markable_id": null,
      "rubric_id": null,
      "rubric_points": null,
      "auto_points": null,
      "status": "unseen",
      "correct": null,
      "response": null,
      "created_at": "2024-05-27T01:25:35.951175+10:00",
      "updated_at": null,
      "content": "<document version=\"2.0\"><paragraph>In the last chapter we wrote a program to help Karel climb a simple ledge:</paragraph><snippet language=\"karel\" runnable=\"true\" line-numbers=\"true\"><snippet-file id=\"code\"># Program: FirstKarel\n# -----------------------------\n# Karel picks up a beeper and places it on a ledge.\n\nfrom karel.stanfordkarel import *\n\ndef main():\n    move()\n    pick_beeper()\n    move()\n    turn_left()\n    move()\n    turn_left()\n    turn_left()\n    turn_left()\n    move()\n    move()\n    put_beeper()\n    move()</snippet-file><snippet-file initial-speed-idx=\"\" id=\"karel-world\">{&#34;width&#34;:6,&#34;height&#34;:4,&#34;initialX&#34;:0,&#34;initialY&#34;:0,&#34;initialD&#34;:1,&#34;initialB&#34;:1000,&#34;cells&#34;:[{&#34;x&#34;:1,&#34;y&#34;:0,&#34;wall&#34;:{&#34;0&#34;:false,&#34;1&#34;:false,&#34;2&#34;:false,&#34;3&#34;:false},&#34;beepers&#34;:1,&#34;colour&#34;:&#34;BLANK&#34;},{&#34;x&#34;:2,&#34;y&#34;:0,&#34;wall&#34;:{&#34;0&#34;:false,&#34;1&#34;:true,&#34;2&#34;:false,&#34;3&#34;:false},&#34;beepers&#34;:0,&#34;colour&#34;:&#34;BLANK&#34;},{&#34;x&#34;:3,&#34;y&#34;:0,&#34;wall&#34;:{&#34;0&#34;:true,&#34;1&#34;:false,&#34;2&#34;:false,&#34;3&#34;:true},&#34;beepers&#34;:0,&#34;colour&#34;:&#34;BLANK&#34;},{&#34;x&#34;:4,&#34;y&#34;:0,&#34;wall&#34;:{&#34;0&#34;:true,&#34;1&#34;:false,&#34;2&#34;:false,&#34;3&#34;:false},&#34;beepers&#34;:0,&#34;colour&#34;:&#34;BLANK&#34;},{&#34;x&#34;:5,&#34;y&#34;:0,&#34;wall&#34;:{&#34;0&#34;:true,&#34;1&#34;:false,&#34;2&#34;:false,&#34;3&#34;:false},&#34;beepers&#34;:0,&#34;colour&#34;:&#34;BLANK&#34;},{&#34;x&#34;:3,&#34;y&#34;:1,&#34;wall&#34;:{&#34;0&#34;:false,&#34;1&#34;:false,&#34;2&#34;:true,&#34;3&#34;:false},&#34;beepers&#34;:0,&#34;colour&#34;:&#34;BLANK&#34;},{&#34;x&#34;:4,&#34;y&#34;:1,&#34;wall&#34;:{&#34;0&#34;:false,&#34;1&#34;:false,&#34;2&#34;:true,&#34;3&#34;:false},&#34;beepers&#34;:0,&#34;colour&#34;:&#34;BLANK&#34;},{&#34;x&#34;:5,&#34;y&#34;:1,&#34;wall&#34;:{&#34;0&#34;:false,&#34;1&#34;:false,&#34;2&#34;:true,&#34;3&#34;:false},&#34;beepers&#34;:0,&#34;colour&#34;:&#34;BLANK&#34;}]}</snippet-file></snippet><paragraph>Even though the <code>FirstKarel</code> program above demonstrates that it is possible to perform the <code>turn_right()</code> operation using only Karel’s built-in commands, the resulting program is not particularly clear conceptually. In your mental design of the program, Karel turns right when it reaches the top of the ledge. The fact that you have to use three <code>turn_left()</code> commands to do so is annoying. It would be much simpler if you could simply say <code>turn_right()</code> and have Karel understand this command. The resulting program would not only be shorter and easier to write, but also significantly easier to read.</paragraph><heading level=\"2\">Defining New Commands</heading><paragraph>Fortunately, the Karel programming language makes it possible to define new commands simply by including new function definitions. Whenever you have a sequence of Karel commands that performs some useful task--such as turning right--you can define a new function that executes that sequence of commands. The format for defining a new Karel function has much the same as the definition of <code>main()</code> in the preceding examples, which is a function definition in its own right. A typical function definition looks like this:</paragraph><pre>def name():\n    commands that make up the body of the function\n</pre><paragraph>In this pattern, name represents the name you have chosen for the new function. To complete the definition, all you have to do is provide the sequence of commands in the lines after the colon, which are all indented by one tab. For example, you can define <code>turn_right()</code> as follows:</paragraph><pre>def turn_right():\n    turn_left()\n    turn_left()\n    turn_left()\n</pre><paragraph>Similarly, you could define a new <code>turn_around()</code> function like this:</paragraph><pre>def turn_around():\n    turn_left()\n    turn_left()\n</pre><paragraph>You can use the name of a new function just like any of Karel’s built-in commands. For example, once you have defined <code>turn_right()</code>, you could replace the three <code>turn_left()</code> commands in the program with a single call to the <code>turn_right()</code> function. Here is a revised implementation of the program that uses <code>turn_right()</code>:</paragraph><snippet language=\"karel\" runnable=\"true\" line-numbers=\"true\"><snippet-file id=\"code\"># Program: BeeperPickingKarel\n# -----------------------------\n# The BeeperPickingKarel program defines a &#34;main&#34; \n# function with three commands. These commands cause  \n# Karel to move forward one block, pick up a  \n# beeper and then move ahead to the next corner.\n\nfrom karel.stanfordkarel import *\n\ndef main():\n    move()\n    pick_beeper()\n    move()\n    turn_left()\n    move()\n    turn_right()\n    move()\n    move()\n    put_beeper()\n    move()\n\ndef turn_right():\n    turn_left()\n    turn_left()\n    turn_left()</snippet-file><snippet-file initial-speed-idx=\"\" id=\"karel-world\">{&#34;width&#34;:6,&#34;height&#34;:4,&#34;initialX&#34;:0,&#34;initialY&#34;:0,&#34;initialD&#34;:1,&#34;initialB&#34;:1000,&#34;cells&#34;:[{&#34;x&#34;:1,&#34;y&#34;:0,&#34;wall&#34;:{&#34;0&#34;:false,&#34;1&#34;:false,&#34;2&#34;:false,&#34;3&#34;:false},&#34;beepers&#34;:1,&#34;colour&#34;:&#34;BLANK&#34;},{&#34;x&#34;:2,&#34;y&#34;:0,&#34;wall&#34;:{&#34;0&#34;:false,&#34;1&#34;:true,&#34;2&#34;:false,&#34;3&#34;:false},&#34;beepers&#34;:0,&#34;colour&#34;:&#34;BLANK&#34;},{&#34;x&#34;:3,&#34;y&#34;:0,&#34;wall&#34;:{&#34;0&#34;:true,&#34;1&#34;:false,&#34;2&#34;:false,&#34;3&#34;:true},&#34;beepers&#34;:0,&#34;colour&#34;:&#34;BLANK&#34;},{&#34;x&#34;:4,&#34;y&#34;:0,&#34;wall&#34;:{&#34;0&#34;:true,&#34;1&#34;:false,&#34;2&#34;:false,&#34;3&#34;:false},&#34;beepers&#34;:0,&#34;colour&#34;:&#34;BLANK&#34;},{&#34;x&#34;:5,&#34;y&#34;:0,&#34;wall&#34;:{&#34;0&#34;:true,&#34;1&#34;:false,&#34;2&#34;:false,&#34;3&#34;:false},&#34;beepers&#34;:0,&#34;colour&#34;:&#34;BLANK&#34;},{&#34;x&#34;:3,&#34;y&#34;:1,&#34;wall&#34;:{&#34;0&#34;:false,&#34;1&#34;:false,&#34;2&#34;:true,&#34;3&#34;:false},&#34;beepers&#34;:0,&#34;colour&#34;:&#34;BLANK&#34;},{&#34;x&#34;:4,&#34;y&#34;:1,&#34;wall&#34;:{&#34;0&#34;:false,&#34;1&#34;:false,&#34;2&#34;:true,&#34;3&#34;:false},&#34;beepers&#34;:0,&#34;colour&#34;:&#34;BLANK&#34;},{&#34;x&#34;:5,&#34;y&#34;:1,&#34;wall&#34;:{&#34;0&#34;:false,&#34;1&#34;:false,&#34;2&#34;:true,&#34;3&#34;:false},&#34;beepers&#34;:0,&#34;colour&#34;:&#34;BLANK&#34;}]}</snippet-file></snippet><heading level=\"2\">Function Code Blocks</heading><paragraph>A group of commands follow the colon <code>:</code> which are indented, is called a <bold>code block</bold>. The body of your function is a code block. Notice how the contents of a code block are all indented one tab in. This is important functionally since it allows Python to know what lines of code are in a given block.</paragraph><paragraph>You can define as many functions as you want. They should all be written one after another. You can&#39;t define a function inside another function.</paragraph><paragraph></paragraph><paragraph></paragraph><paragraph>Based on work by Chris Piech and Eric Roberts at Stanford University.<break></break><link href=\"https://compedu.stanford.edu/karel-reader/docs/python/en/intro.html\">https://compedu.stanford.edu/karel-reader/docs/python/en/intro.html</link></paragraph></document>"
    },
    {
      "id": 361899,
      "original_id": 326060,
      "lesson_id": 53291,
      "user_id": 93339,
      "course_id": 16645,
      "type": "document",
      "title": "4. Decomposition",
      "index": 4,
      "is_hidden": false,
      "lesson_markable_id": null,
      "rubric_id": null,
      "rubric_points": null,
      "auto_points": null,
      "status": "unseen",
      "correct": null,
      "response": null,
      "created_at": "2024-05-27T01:25:35.951175+10:00",
      "updated_at": null,
      "content": "<document version=\"2.0\"><paragraph>As a way of illustrating more of the power that comes with being able to define new functions, it’s useful to have Karel do something a little more practical than move a beeper from one place to another. The roadways often seem to be in need of repair, and it might be fun to see if Karel can fill potholes in its abstract world. For example, imagine that Karel is standing on the “road” shown in the following figure, one corner to the left of a pothole in the road. Karel’s job is to fill the hole with a beeper and proceed to the next corner. </paragraph><figure><image height=\"241\" src=\"https://static.ap.edusercontent.com/files/6HSdqhprA8fsjQiIWUUuFmVv\" width=\"288\"></image></figure><paragraph>The following diagram illustrates how the world should look after the program execution.</paragraph><figure><image height=\"241\" src=\"https://static.ap.edusercontent.com/files/G5MuXPfewZtNrkev9UBVtaWp\" width=\"287\"></image></figure><paragraph>If you are limited to the four predefined commands, the <code>main()</code> function to solve this problem would look like this:</paragraph><pre>def main():\n    move()\n    turn_left()\n    turn_left()\n    turn_left()\n    move()\n    put_beeper()\n    turn_left()\n    turn_left()\n    move()\n    turn_left()\n    turn_left()\n    turn_left()\n    move()\n</pre><paragraph>The initial motivation for defining the <code>turn_right()</code> function was that it was cumbersome to keep repeating three <code>turn_left()</code> commands to accomplish a right turn. Defining new functions has another important purpose beyond allowing you to avoid repeating the same command sequences every time you want to perform a particular task. The power to define functions unlocks the most important strategy in programming—the process of breaking a large problem down into smaller pieces that are easier to solve. The process of breaking a program down into smaller pieces is called decomposition, and the component parts of a large problem are called subproblems.</paragraph><paragraph>As an example, the problem of filling the hole in the roadway can be decomposed into the following subproblems:</paragraph><list style=\"number\"><list-item><paragraph>Move up to the hole</paragraph></list-item><list-item><paragraph>Fill the hole by dropping a beeper into it</paragraph></list-item><list-item><paragraph>Move on to the next corner</paragraph></list-item></list><paragraph>If you think about the problem in this way, you can use function definitions to create a program that reflects your conception of the program structure. The main function would look like this:</paragraph><pre>def main():\n    move()\n    fill_pothole()\n    move()\n</pre><paragraph>The correspondence with the outline is immediately clear, and everything would be great if only you could get Karel to understand what you mean by <code>fill_pothole()</code>. Given the power to define functions, implementing <code>fill_pothole()</code> is extremely simple. All you have to do is define a <code>fill_pothole()</code> function whose body consists of the commands you have already written to do the job, like this:</paragraph><pre>def fill_pothole():\n    turn_right()\n    move()\n    put_beeper()\n    turn_around()\n    move()\n    turn_right()\n</pre><paragraph>Here is the complete program. Notice how you can understand the programmer&#39;s intent simply from reading the main function. When you run the program, the line highlighting shows how a computer will execute it, step by step. However, because the program is nicely broken down we can understand it on a human thought level:</paragraph><snippet line-numbers=\"true\" language=\"karel\" runnable=\"true\"><snippet-file id=\"code\">from karel.stanfordkarel import *\n\ndef main():\n    move()\n    fill_pothole()\n    move()\n\n# Fills the pothole beneath Karel&#39;s current position by \n# placing a beeper on that corner. For this function to work \n# correctly, Karel must be facing east immediately above the \n# pothole. When execution is complete, Karel will have \n# returned to the same square and will again be facing east.\ndef fill_pothole():\n    turn_right()\n    move()\n    put_beeper()\n    turn_around()\n    move()\n    turn_right()\n\n# Turns Karel 90 degrees to the right. \ndef turn_right():\n    turn_left()\n    turn_left()\n    turn_left()\n\n# Turns Karel around 180 degrees. \ndef turn_around():\n    turn_left()\n    turn_left()</snippet-file><snippet-file id=\"karel-world\" initial-speed-idx=\"\">{&#34;width&#34;:5,&#34;height&#34;:4,&#34;initialX&#34;:0,&#34;initialY&#34;:1,&#34;initialD&#34;:1,&#34;initialB&#34;:1000,&#34;cells&#34;:[{&#34;x&#34;:0,&#34;y&#34;:0,&#34;wall&#34;:{&#34;0&#34;:true,&#34;1&#34;:true,&#34;2&#34;:false,&#34;3&#34;:false},&#34;beepers&#34;:0,&#34;colour&#34;:&#34;BLANK&#34;},{&#34;x&#34;:1,&#34;y&#34;:0,&#34;wall&#34;:{&#34;0&#34;:false,&#34;1&#34;:true,&#34;2&#34;:false,&#34;3&#34;:true},&#34;beepers&#34;:0,&#34;colour&#34;:&#34;BLANK&#34;},{&#34;x&#34;:2,&#34;y&#34;:0,&#34;wall&#34;:{&#34;0&#34;:true,&#34;1&#34;:false,&#34;2&#34;:false,&#34;3&#34;:true},&#34;beepers&#34;:0,&#34;colour&#34;:&#34;BLANK&#34;},{&#34;x&#34;:3,&#34;y&#34;:0,&#34;wall&#34;:{&#34;0&#34;:true,&#34;1&#34;:false,&#34;2&#34;:false,&#34;3&#34;:false},&#34;beepers&#34;:0,&#34;colour&#34;:&#34;BLANK&#34;},{&#34;x&#34;:4,&#34;y&#34;:0,&#34;wall&#34;:{&#34;0&#34;:true,&#34;1&#34;:false,&#34;2&#34;:false,&#34;3&#34;:false},&#34;beepers&#34;:0,&#34;colour&#34;:&#34;BLANK&#34;},{&#34;x&#34;:0,&#34;y&#34;:1,&#34;wall&#34;:{&#34;0&#34;:false,&#34;1&#34;:false,&#34;2&#34;:true,&#34;3&#34;:false},&#34;beepers&#34;:0,&#34;colour&#34;:&#34;BLANK&#34;},{&#34;x&#34;:2,&#34;y&#34;:1,&#34;wall&#34;:{&#34;0&#34;:false,&#34;1&#34;:false,&#34;2&#34;:true,&#34;3&#34;:false},&#34;beepers&#34;:0,&#34;colour&#34;:&#34;BLANK&#34;},{&#34;x&#34;:3,&#34;y&#34;:1,&#34;wall&#34;:{&#34;0&#34;:false,&#34;1&#34;:false,&#34;2&#34;:true,&#34;3&#34;:false},&#34;beepers&#34;:0,&#34;colour&#34;:&#34;BLANK&#34;},{&#34;x&#34;:4,&#34;y&#34;:1,&#34;wall&#34;:{&#34;0&#34;:false,&#34;1&#34;:false,&#34;2&#34;:true,&#34;3&#34;:false},&#34;beepers&#34;:0,&#34;colour&#34;:&#34;BLANK&#34;}]}</snippet-file></snippet><paragraph></paragraph><paragraph></paragraph><paragraph>Based on work by Chris Piech and Eric Roberts at Stanford University.<break></break><link href=\"https://compedu.stanford.edu/karel-reader/docs/python/en/intro.html\">https://compedu.stanford.edu/karel-reader/docs/python/en/intro.html</link></paragraph></document>"
    },
    {
      "id": 361900,
      "original_id": 326061,
      "lesson_id": 53291,
      "user_id": 93339,
      "course_id": 16645,
      "type": "document",
      "title": "5. For Loops",
      "index": 5,
      "is_hidden": false,
      "lesson_markable_id": null,
      "rubric_id": null,
      "rubric_points": null,
      "auto_points": null,
      "status": "unseen",
      "correct": null,
      "response": null,
      "created_at": "2024-05-27T01:25:35.951175+10:00",
      "updated_at": null,
      "content": "<document version=\"2.0\"><paragraph>One of the things that computers are especially good at is repetition. How can we convince Karel to execute a block of code multiple times? To see how repetition can be used, consider the task of placing 42 beepers:</paragraph><figure><image height=\"277\" src=\"https://static.ap.edusercontent.com/files/iYqlkXAfTQiF75YPdDczGE5x\" width=\"271\"></image></figure><figure><image src=\"https://static.ap.edusercontent.com/files/PsUL8Em2ffXZ4dAifb3q4diq\" width=\"270\" height=\"272\"></image></figure><heading level=\"2\">Basic For Loop</heading><paragraph>Since you know that there are exactly 42 beepers to place, the control statement that you need is a <bold>for loop</bold>, which specifies that you want to repeat some operation a fixed number of times. The structure of the <code>for</code> statement appears complicated primarily because it is actually much more powerful than anything Karel needs. The only version of the <code>for</code> syntax that Karel uses is:</paragraph><pre>for i in range(count):\n    statements to be repeated\n</pre><paragraph>We will go over all the details of the <code>for</code> loop later in the class. For now you should read this line as a way to express, &#34;repeat the statements in the function body <italic>count</italic> times.&#34; We can use this new <bold>for loop</bold> to place 42 beepers by replacing <italic>count</italic> with 42 and putting the command <code>put_beeper()</code> inside of the <code>for</code> loop code block. We call commands in the code block the <bold>body</bold>:</paragraph><snippet runnable=\"true\" line-numbers=\"true\" language=\"karel\"><snippet-file id=\"code\"># Program: PlaceManyBeepers\n# -----------------------------\n# Places 42 beepers using a for loop\n\nfrom karel.stanfordkarel import *\n\ndef main():\n    move()\n    # Repeat put_beeper many times \n    for i in range(42):\n        put_beeper()\n    move()</snippet-file><snippet-file id=\"karel-world\" initial-speed-idx=\"4\">{&#34;width&#34;:4,&#34;height&#34;:4,&#34;initialX&#34;:0,&#34;initialY&#34;:0,&#34;initialD&#34;:1,&#34;initialB&#34;:1000,&#34;cells&#34;:[]}</snippet-file></snippet><paragraph><bold>The code above is editable</bold>. Try to change it so that it places only 15 beepers.</paragraph><heading level=\"2\">Matching Postconditions with Preconditions</heading><paragraph>The previous example gives the impression that a <code>for</code> loop repeats a single line of code. However the body of the <code>for</code> loop (the statements that get repeated) can be multiple lines. Here is an example of a program that puts a beeper in each corner of a world:</paragraph><snippet line-numbers=\"true\" language=\"karel\" runnable=\"true\"><snippet-file id=\"code\"># Program: CornerBeepers\n# -----------------------------\n# Places one beeper in each corner\n\nfrom karel.stanfordkarel import *\n\ndef main():\n    # Repeat the body 4 times \n    for i in range(4):\n        put_beeper()\n        move()\n        move()\n        move()\n        turn_left()</snippet-file><snippet-file id=\"karel-world\" initial-speed-idx=\"\">{&#34;width&#34;:4,&#34;height&#34;:4,&#34;initialX&#34;:0,&#34;initialY&#34;:0,&#34;initialD&#34;:1,&#34;initialB&#34;:1000,&#34;cells&#34;:[]}</snippet-file></snippet><paragraph>Pay very close attention to the way that the program flows through these control statements. The program runs through the set of commands in the <code>for</code> loop body one at a time. It repeats the body four times.</paragraph><paragraph>Perhaps the single most complicated part of writing a loop is that you need the state of the world at the end of the loop (the <bold>postcondition</bold>) to be a valid state of the world for the start of the loop (the <bold>precondition</bold>). In the above example the assumptions match. Good times. At the start of the loop, Karel is always on a square with no beepers facing the next empty corner. What if you deleted the <code>turn_left()</code> at the end of the loop? The postcondition at the end of the first iteration would no longer satisfy the assumptions made about Karel facing the next empty corner. The code is editable. Try deleting the <code>turn_left()</code> command to see what happens!</paragraph><heading level=\"2\">Nested Loops</heading><paragraph>Technically the body of a <code>for</code> loop can contain any control flow code, even other loops. Here is an example of a <code>for</code> loop that repeats a call to a function which also has a <code>for</code> loop. We call this a &#34;nested&#34; loop. Try to read through the program, and understand what it does, before running it:</paragraph><snippet language=\"karel\" runnable=\"true\" line-numbers=\"true\"><snippet-file id=\"code\"># Program: CornerFiveBeepers\n# -----------------------------\n# Places five beepers in each corner\n\nfrom karel.stanfordkarel import *\n\ndef main():\n    # Repeat once for each corner \n    for i in range(4):\n        put_five_beepers()\n        move_to_next_corner()\n\n# Reposition karel to the next corner \ndef move_to_next_corner() :\n    move()\n    move()\n    move()\n    turn_left()\n\n# Places 5 beepers using a for loop \ndef put_five_beepers() :\n    for i in range(5):\n        put_beeper()</snippet-file><snippet-file id=\"karel-world\" initial-speed-idx=\"\">{&#34;width&#34;:4,&#34;height&#34;:4,&#34;initialX&#34;:0,&#34;initialY&#34;:0,&#34;initialD&#34;:1,&#34;initialB&#34;:1000,&#34;cells&#34;:[]}</snippet-file></snippet><paragraph></paragraph><paragraph></paragraph><paragraph>Based on work by Chris Piech and Eric Roberts at Stanford University.<break></break><link href=\"https://compedu.stanford.edu/karel-reader/docs/python/en/intro.html\">https://compedu.stanford.edu/karel-reader/docs/python/en/intro.html</link></paragraph></document>"
    },
    {
      "id": 361901,
      "original_id": 326062,
      "lesson_id": 53291,
      "user_id": 93339,
      "course_id": 16645,
      "type": "document",
      "title": "6. While Loops",
      "index": 6,
      "is_hidden": false,
      "lesson_markable_id": null,
      "rubric_id": null,
      "rubric_points": null,
      "auto_points": null,
      "status": "unseen",
      "correct": null,
      "response": null,
      "created_at": "2024-05-27T01:25:35.951175+10:00",
      "updated_at": null,
      "content": "<document version=\"2.0\"><paragraph>The technique of defining new functions, and defining for loops—as useful as they are—does not actually enable Karel to solve any new problems. Every time you run a program it always does exactly the same thing. Programs become a lot more useful when they can respond differently to different inputs.</paragraph><paragraph>As an example. Let&#39;s say you wanted to write a program to have Karel move to a wall. But you don&#39;t simply want this program to work on one world with a fixed size. You would like to write a single program that could work on any world.</paragraph><snippet language=\"karel\" runnable=\"true\" line-numbers=\"true\"><snippet-file id=\"code\"># Program: MoveToWall\n# ------------------------------\n# Uses a &#34;while&#34; loop to move Karel until it hits\n# a wall. Works on any sized world.\nfrom karel.stanfordkarel import *\n\n# the program starts with main\ndef main():\n    # call the move to wall function\n    move_to_wall()\n\n# this is a very useful function\ndef move_to_wall():\n    # repeat the body while the condition holds\n    while front_is_clear():\n        move()</snippet-file><snippet-file id=\"karel-world\" initial-speed-idx=\"\">{&#34;width&#34;:7,&#34;height&#34;:7,&#34;initialX&#34;:0,&#34;initialY&#34;:0,&#34;initialD&#34;:1,&#34;initialB&#34;:1000,&#34;cells&#34;:[]}</snippet-file></snippet><paragraph>Try changing the world by clicking the numbers above the world. For any sized world, Karel will move until it hits a wall. Notice that this feat can not be accomplished using a <code>for</code> loop. That would require us to know the size of the world at the time of programming.</paragraph><heading level=\"2\">Basic While Loop</heading><paragraph>In Karel, a <code>while</code> loop is used to repeat a body of code <italic>as-long-as</italic> a given condition holds. The <code>while</code> loop has the following general form:</paragraph><pre>while test:\n    statements to be repeated\n</pre><paragraph>The control-flow of a <code>while</code> loop is as follows. When the program hits a <code>while</code> loop it starts repeating a process where it first <italic>checks</italic> if the test passes, and if so <italic>runs</italic> the code in the body.</paragraph><paragraph>When the program <italic>checks</italic> if the test passes, it decides if the <italic>test</italic> is true for the current state of the world. If so, the loop will run the code in the body. If the test fails, the loop is over and the program moves on.</paragraph><paragraph>When the program <italic>runs</italic> the body of the loop, the program executes the lines in the body one at a time. When the program arrives at the end of the <code>while</code> loop, it jumps back to the top of the loop. It then rechecks the test, continuing to loop if it passes. The program does not exit the loop until it gets to a check, and the test fails.</paragraph><paragraph>Karel has many <italic>test</italic> statements, and we will go over all of them in the next chapter. For now we are going to use a single test statement: <code>front_is_clear()</code> which is true if there is no wall directly in front of Karel.</paragraph><heading level=\"2\">Fencepost Bug</heading><paragraph>Let&#39;s modify our program above to make it more interesting. Instead of just moving to a wall, have Karel place a line of beepers, one in each square. Again we want this program to work for a world of any size:</paragraph><snippet language=\"karel\" runnable=\"true\" line-numbers=\"true\"><snippet-file id=\"code\"># Program: BeeperLineBug\n# ------------------------------\n# Uses a while loop to place a line of beepers.\n# This program works for a world of any size.\n# However, because each world requires one fewer\n# moves than put_beepers it always misses a beeper.\n\nfrom karel.stanfordkarel import *\n\ndef main():\n    # Repeat until karel faces a wall\n    while front_is_clear():\n        # Place a beeper on current square\n        put_beeper()\n        # Move to the next square\n        move()</snippet-file><snippet-file id=\"karel-world\" initial-speed-idx=\"\">{&#34;width&#34;:7,&#34;height&#34;:7,&#34;initialX&#34;:0,&#34;initialY&#34;:0,&#34;initialD&#34;:1,&#34;initialB&#34;:1000,&#34;cells&#34;:[]}</snippet-file></snippet><paragraph>That looks great. Except for one problem. On every world Karel doesn&#39;t place a beeper on the last square of the line (look closely). When Karel is on the last square, the program does not execute the body of the loop because the test no longer passes -- Karel is facing a wall. You might be tempted to try switching the order of the body so that Karel moves before placing a beeper. The code is editable so go try it!</paragraph><paragraph>There is a deeper problem that no rearrangement of the body can solve. For the world with 7 columns, Karel needs to put 7 beepers, but should only move 6 times. Since the <code>while</code> loop executes both lines when a test passes, how can you get the program to execute one command one more time than the other?</paragraph><paragraph>The bug in this program is an example of a programming problem called a <bold>fencepost error</bold>. The name comes from the fact that if you want to build a fence made of panels which have one fence post on either size, the number of fence posts is always one greater than the number of panels. How many fence posts, for example, do you need to build a fence with 10 panels? The answer is 11, as illustrated by the following diagram:</paragraph><paragraph></paragraph><figure><image src=\"https://static.ap.edusercontent.com/files/Utx8Uvis0uwdZ02aDez2h1XO\" width=\"743\" height=\"199.26977848101268\"></image></figure><paragraph>Once you discover it, fixing this bug is actually quite easy. Before Karel stops at the end of the world, all that the program has to do is place a final beeper:</paragraph><snippet language=\"karel\" runnable=\"true\" line-numbers=\"true\"><snippet-file id=\"code\"># Program: BeeperLine\n# ------------------------------\n# Uses a while loop to place a line of beepers.\n# This program works for a world of any size.\n\nfrom karel.stanfordkarel import *\n\ndef main():\n    # Repeat until karel faces a wall\n    while front_is_clear():\n        # Place a beeper on current square\n        put_beeper()\n        # Move to the next square\n        move()\n    # Solve the fencepost error\n    put_beeper()</snippet-file><snippet-file id=\"karel-world\" initial-speed-idx=\"\">{&#34;width&#34;:7,&#34;height&#34;:7,&#34;initialX&#34;:0,&#34;initialY&#34;:0,&#34;initialD&#34;:1,&#34;initialB&#34;:1000,&#34;cells&#34;:[]}</snippet-file></snippet><paragraph></paragraph><paragraph></paragraph><paragraph>Based on work by Chris Piech and Eric Roberts at Stanford University.<break></break><link href=\"https://compedu.stanford.edu/karel-reader/docs/python/en/intro.html\">https://compedu.stanford.edu/karel-reader/docs/python/en/intro.html</link></paragraph></document>"
    },
    {
      "id": 361902,
      "original_id": 326063,
      "lesson_id": 53291,
      "user_id": 93339,
      "course_id": 16645,
      "type": "document",
      "title": "7. If Statements",
      "index": 7,
      "is_hidden": false,
      "lesson_markable_id": null,
      "rubric_id": null,
      "rubric_points": null,
      "auto_points": null,
      "status": "unseen",
      "correct": null,
      "response": null,
      "created_at": "2024-05-27T01:25:35.951175+10:00",
      "updated_at": null,
      "content": "<document version=\"2.0\"><paragraph>The final core programming control-flow construct to learn are conditional statements (<code>if</code> and <code>if/else</code>).</paragraph><heading level=\"2\">Basic Conditionals</heading><paragraph>An <code>if/else</code> statement executes an &#34;if&#34; code-block if and only if the provided <italic>test</italic> is true for the state of the world at the time the program reaches the statement. Otherwise the program executes the &#34;else&#34; code-block.</paragraph><pre>if test:\n    if code-block\nelse:\n    else code-block\n</pre><paragraph>To get a sense of where conditional statements might come in handy, let&#39;s write a program that has Karel invert a line of beepers. If a square previously had a beeper, Karel should pick it up. If a square has no beeper, Karel should put one down.</paragraph><snippet line-numbers=\"true\" language=\"karel\" runnable=\"true\"><snippet-file id=\"code\"># Program: UpAndDown\n# -----------------------------\n\nfrom karel.stanfordkarel import *\n\ndef main():\n    while front_is_clear():\n        invert_beeper()\n        move()\n    # Prevent a fencepost bug\n    invert_beeper()\n\n# Picks up a beeper if one is present\n# Puts down a beeper otherwise\ndef invert_beeper():\n    # An if/else statement\n    if beepers_present():\n        pick_beeper()\n    else:\n        put_beeper()</snippet-file><snippet-file id=\"karel-world\" initial-speed-idx=\"\">{&#34;width&#34;:8,&#34;height&#34;:8,&#34;initialX&#34;:0,&#34;initialY&#34;:0,&#34;initialD&#34;:1,&#34;initialB&#34;:1000,&#34;cells&#34;:[{&#34;x&#34;:1,&#34;y&#34;:0,&#34;wall&#34;:{&#34;0&#34;:false,&#34;1&#34;:false,&#34;2&#34;:false,&#34;3&#34;:false},&#34;beepers&#34;:1,&#34;colour&#34;:&#34;BLANK&#34;},{&#34;x&#34;:3,&#34;y&#34;:0,&#34;wall&#34;:{&#34;0&#34;:false,&#34;1&#34;:false,&#34;2&#34;:false,&#34;3&#34;:false},&#34;beepers&#34;:1,&#34;colour&#34;:&#34;BLANK&#34;},{&#34;x&#34;:4,&#34;y&#34;:0,&#34;wall&#34;:{&#34;0&#34;:false,&#34;1&#34;:false,&#34;2&#34;:false,&#34;3&#34;:false},&#34;beepers&#34;:1,&#34;colour&#34;:&#34;BLANK&#34;},{&#34;x&#34;:6,&#34;y&#34;:0,&#34;wall&#34;:{&#34;0&#34;:false,&#34;1&#34;:false,&#34;2&#34;:false,&#34;3&#34;:false},&#34;beepers&#34;:1,&#34;colour&#34;:&#34;BLANK&#34;}]}</snippet-file></snippet><paragraph>Note that an <code>if</code> statement does not need to have an <code>else</code> block -- in which case the statement operates like a <code>while</code> loop that only executes one time:</paragraph><pre>if test:\n    if code-block\n</pre><heading level=\"2\">Conditions</heading><paragraph>That last example used a new condition. Here is a list of all of the conditions that Karel knows of:</paragraph><web-snippet layout=\"seamless\"><web-snippet-file language=\"html\">&lt;link rel=&#34;stylesheet&#34; href=&#34;https://unpkg.com/purecss@2.0.3/build/pure-min.css&#34; integrity=&#34;sha384-cg6SkqEOCV1NbJoCu11+bm0NvBRc8IYLRGXkmNrqUBfTjmMYwNKPWBTIKyw9mHNJ&#34; crossorigin=&#34;anonymous&#34;&gt;\n\n&lt;table class=&#34;pure-table&#34;&gt;\n  &lt;thead&gt;\n    &lt;tr&gt;&lt;th&gt;Test&lt;/th&gt;&lt;th&gt;Opposite&lt;/th&gt;&lt;th&gt;What it checks&lt;/th&gt;&lt;/tr&gt;\n  &lt;/thead&gt;\n  &lt;tr&gt;\n  &#x9;&lt;td&gt;&lt;code&gt;front_is_clear()&lt;/code&gt;&lt;/td&gt;\n  &#x9;&lt;td&gt;&lt;code&gt;front_is_blocked()&lt;/code&gt;&lt;/td&gt;\n  &#x9;&lt;td&gt;Is there a wall in front of Karel?&lt;/td&gt;\n  &lt;/tr&gt;\n  &lt;tr&gt;\n  &#x9;&lt;td&gt;&lt;code&gt;beepers_present()&lt;/code&gt;&lt;/td&gt;\n  &#x9;&lt;td&gt;&lt;code&gt;no_beepers_present()&lt;/code&gt;&lt;/td&gt;\n  &#x9;&lt;td&gt;Are there beepers on this corner?&lt;/td&gt;\n  &lt;/tr&gt;\n  &lt;tr&gt;\n  &#x9;&lt;td&gt;&lt;code&gt;left_is_clear()&lt;/code&gt;&lt;/td&gt;\n  &#x9;&lt;td&gt;&lt;code&gt;left_is_blocked()&lt;/code&gt;&lt;/td&gt;\n  &#x9;&lt;td&gt;Is there a wall to Karel’s left?&lt;/td&gt;\n  &lt;/tr&gt;\n  &lt;tr&gt;\n  &#x9;&lt;td&gt;&lt;code&gt;right_is_clear()&lt;/code&gt;&lt;/td&gt;\n  &#x9;&lt;td&gt;&lt;code&gt;right_is_blocked()&lt;/code&gt;&lt;/td&gt;\n  &#x9;&lt;td&gt;Is there a wall to Karel’s right?&lt;/td&gt;\n  &lt;/tr&gt;\n  &lt;tr&gt;\n    &lt;td&gt;&lt;code&gt;beepers_in_bag()&lt;/code&gt;&lt;/td&gt;\n    &lt;td&gt;&lt;code&gt;no_beepers_in_bag()&lt;/code&gt;&lt;/td&gt;\n    &lt;td&gt;Does Karel have any beepers in its bag?&lt;/td&gt;\n  &lt;/tr&gt;\n  &lt;!-- dirs --&gt;\n  &lt;tr&gt;\n  &#x9;&lt;td&gt;&lt;code&gt;facing_north()&lt;/code&gt;&lt;/td&gt;\n  &#x9;&lt;td&gt;&lt;code&gt;not_facing_north()&lt;/code&gt;&lt;/td&gt;\n  &#x9;&lt;td&gt;Is Karel facing north?&lt;/td&gt;\n  &lt;/tr&gt;\n  &lt;tr&gt;\n  &#x9;&lt;td&gt;&lt;code&gt;facing_south()&lt;/code&gt;&lt;/td&gt;\n  &#x9;&lt;td&gt;&lt;code&gt;not_facing_south()&lt;/code&gt;&lt;/td&gt;\n  &#x9;&lt;td&gt;Is Karel facing south?&lt;/td&gt;\n  &lt;/tr&gt;\n  &lt;tr&gt;\n  &#x9;&lt;td&gt;&lt;code&gt;facing_east()&lt;/code&gt;&lt;/td&gt;\n  &#x9;&lt;td&gt;&lt;code&gt;not_facing_east()&lt;/code&gt;&lt;/td&gt;\n  &#x9;&lt;td&gt;Is Karel facing east?&lt;/td&gt;\n  &lt;/tr&gt;\n  &lt;tr&gt;\n  &#x9;&lt;td&gt;&lt;code&gt;facing_west()&lt;/code&gt;&lt;/td&gt;\n  &#x9;&lt;td&gt;&lt;code&gt;not_facing_west()&lt;/code&gt;&lt;/td&gt;\n  &#x9;&lt;td&gt;Is Karel facing west?&lt;/td&gt;\n  &lt;/tr&gt;\n&lt;/table&gt;\n&lt;/p&gt;</web-snippet-file><web-snippet-file language=\"css\"></web-snippet-file><web-snippet-file language=\"js\"></web-snippet-file></web-snippet><heading level=\"2\">Putting it all together</heading><paragraph>Congrats! You now know all of the core programming control-flow blocks. While you learned them with Karel, methods, while loops, for loops, if/else statements work in the same way in almost all major languages, including Python.</paragraph><paragraph>Now that you have the building blocks you can put them together to build solutions to ever more complex problems. To a large extent, programming is the science of solving problems by computer. Because problems are often difficult, solutions—and the programs that implement those solutions—can be difficult as well. In order to make it easier for you to develop those solutions, you need to adopt a methodology and discipline that reduces the level of that complexity to a manageable scale.</paragraph><paragraph></paragraph><paragraph></paragraph><paragraph>Based on work by Chris Piech and Eric Roberts at Stanford University.<break></break><link href=\"https://compedu.stanford.edu/karel-reader/docs/python/en/intro.html\">https://compedu.stanford.edu/karel-reader/docs/python/en/intro.html</link></paragraph></document>"
    },
    {
      "id": 361903,
      "original_id": 326064,
      "lesson_id": 53291,
      "user_id": 93339,
      "course_id": 16645,
      "type": "document",
      "title": "8. Code",
      "index": 8,
      "is_hidden": false,
      "lesson_markable_id": null,
      "rubric_id": null,
      "rubric_points": null,
      "auto_points": null,
      "status": "unseen",
      "correct": null,
      "response": null,
      "created_at": "2024-05-27T01:25:35.951175+10:00",
      "updated_at": null,
      "content": "<document version=\"2.0\"><heading level=\"2\">Write and test any code here!</heading><snippet language=\"karel\" runnable=\"true\" line-numbers=\"true\"><snippet-file id=\"code\">from karel.stanfordkarel import *\n\ndef main():\n    # your code here...\n    move()</snippet-file><snippet-file id=\"karel-world\" initial-speed-idx=\"\"></snippet-file></snippet></document>"
    }
  ],
  "solutions_at": null,
  "state": "active",
  "status": "unattempted",
  "submitted_at": null,
  "timer_duration": 60,
  "timer_effective_duration": 60,
  "timer_expiration_access": false,
  "title": "Meet Karel the Robot",
  "tutorial_regex": "",
  "type": "karel",
  "updated_at": null,
  "user_id": 93339
}