{
  "attempt_id": null,
  "attempted_at": null,
  "attempts": null,
  "attempts_remaining": null,
  "available_at": null,
  "clean_attempts": false,
  "course_id": 16645,
  "created_at": "2024-05-27T01:25:47.394393+10:00",
  "due_at": null,
  "effective_available_at": null,
  "effective_due_at": null,
  "effective_locked_at": null,
  "first_viewed_at": null,
  "grade_passback_auto_send": false,
  "grade_passback_mode": "",
  "grade_passback_scale_to": null,
  "id": 53336,
  "index": 3,
  "inverse_regex": false,
  "is_hidden": false,
  "is_timed": false,
  "is_unlisted": false,
  "kind": "content",
  "last_viewed_slide_id": null,
  "late_submissions": true,
  "locked_at": null,
  "module_id": 11529,
  "number": -1,
  "openable": false,
  "openable_without_attempt": false,
  "original_id": 47914,
  "outline": "",
  "password": "",
  "password_one_time": false,
  "prerequisites": [],
  "release_challenge_solutions": false,
  "release_challenge_solutions_while_active": true,
  "release_feedback": false,
  "release_feedback_while_active": false,
  "release_quiz_correctness_only": false,
  "release_quiz_solutions": false,
  "reopen_submissions": false,
  "require_user_override": false,
  "settings": {
    "quiz_question_number_style": "",
    "quiz_mode": "multiple-attempts",
    "quiz_active_status": "active"
  },
  "slide_count": 8,
  "slide_marks_summary": [
    {
      "id": 362111,
      "is_hidden": false,
      "rubric_points": 0,
      "auto_points": 0,
      "scoring_mode": "",
      "scale_to": null,
      "scale_to_auto": null,
      "scale_to_rubric": null
    },
    {
      "id": 362113,
      "is_hidden": false,
      "rubric_points": 0,
      "auto_points": 0,
      "scoring_mode": "",
      "scale_to": null,
      "scale_to_auto": null,
      "scale_to_rubric": null
    },
    {
      "id": 362114,
      "is_hidden": false,
      "rubric_points": 0,
      "auto_points": 0,
      "scoring_mode": "",
      "scale_to": null,
      "scale_to_auto": null,
      "scale_to_rubric": null
    },
    {
      "id": 362115,
      "is_hidden": false,
      "rubric_points": 0,
      "auto_points": 25,
      "scoring_mode": "",
      "scale_to": null,
      "scale_to_auto": null,
      "scale_to_rubric": null
    },
    {
      "id": 362116,
      "is_hidden": false,
      "rubric_points": 0,
      "auto_points": 0,
      "scoring_mode": "",
      "scale_to": null,
      "scale_to_auto": null,
      "scale_to_rubric": null
    },
    {
      "id": 362117,
      "is_hidden": false,
      "rubric_points": 0,
      "auto_points": 0,
      "scoring_mode": "",
      "scale_to": null,
      "scale_to_auto": null,
      "scale_to_rubric": null
    },
    {
      "id": 362118,
      "is_hidden": false,
      "rubric_points": 0,
      "auto_points": 0,
      "scoring_mode": "",
      "scale_to": null,
      "scale_to_auto": null,
      "scale_to_rubric": null
    },
    {
      "id": 367850,
      "is_hidden": false,
      "rubric_points": 0,
      "auto_points": 0,
      "scoring_mode": "",
      "scale_to": null,
      "scale_to_auto": null,
      "scale_to_rubric": null
    }
  ],
  "slides": [
    {
      "id": 362111,
      "original_id": 340285,
      "lesson_id": 53336,
      "user_id": 93339,
      "course_id": 16645,
      "type": "code",
      "title": "Exercise 1: Outlier remover",
      "index": 2,
      "is_hidden": false,
      "lesson_markable_id": null,
      "rubric_id": null,
      "rubric_points": null,
      "auto_points": null,
      "status": "unseen",
      "correct": null,
      "response": null,
      "created_at": "2024-05-27T01:25:47.394393+10:00",
      "updated_at": null,
      "challenge_id": 119399,
      "content": "<document version=\"2.0\"><paragraph>When you calculate the mean of a collection of numbers the result can be adversely affected by <bold>outliers</bold> - values that are extreme, either extremely small or extremely large.</paragraph><paragraph>Write a program in which you define a function that takes a <bold>list of numbers</bold> as <bold>argument</bold> and <bold>returns</bold> their <bold>mean</bold>, but when it calculates the mean it ignores the smallest number and the largest number. Give your function an informative name.</paragraph><paragraph>Illustrate the use of the function by applying it to some example lists.</paragraph><paragraph>Some things to be careful of:</paragraph><list style=\"bullet\"><list-item><paragraph>Make sure your function <bold>doesn't change the list that it receives</bold>.</paragraph></list-item><list-item><paragraph>Make sure your function <bold>can handle lists that have fewer than 3 elements</bold>.</paragraph></list-item><list-item><paragraph>Make sure your function <bold>can handle lists that contain non-numeric values</bold>.</paragraph></list-item></list></document>"
    },
    {
      "id": 362113,
      "original_id": 340287,
      "lesson_id": 53336,
      "user_id": 93339,
      "course_id": 16645,
      "type": "code",
      "title": "Exercise 2: Memoizer",
      "index": 4,
      "is_hidden": false,
      "lesson_markable_id": null,
      "rubric_id": null,
      "rubric_points": null,
      "auto_points": null,
      "status": "unseen",
      "correct": null,
      "response": null,
      "created_at": "2024-05-27T01:25:47.394393+10:00",
      "updated_at": null,
      "challenge_id": 119401,
      "content": "<document version=\"2.0\"><paragraph>Suppose you have a <bold>function</bold> that <bold>takes a value</bold> and <bold>returns a value</bold> but the <bold>calculation</bold> it uses <bold>consumes a lot of time and resources</bold>.</paragraph><paragraph>If the function always returns the same value when given the same value, then it can be a good idea to get the function to <bold>remember</bold> the results of its calculations. Then, if the function is passed a value that it has already had, it can simply <bold>recall</bold> the result of the calculation rather than <bold>doing the calculation</bold> again. This technique is called <bold>memoization</bold>.</paragraph><paragraph>Write a program in which you define a <bold>function</bold> that <bold>finds the cube of a number</bold>. Get it to <bold>use memoization</bold>. Memoization is not really needed in this case, because the calculation is not time or resource intensive, but it will <bold>illustrate the principles</bold>.</paragraph><paragraph>Here is one way to proceed:</paragraph><list style=\"bullet\"><list-item><paragraph>Define your function as normal</paragraph></list-item><list-item><paragraph>Add an <bold>attribute</bold> to the function, whose value is a <bold>dictionary</bold>.</paragraph></list-item><list-item><paragraph>When the function is called with a number it can check this dictionary to see if it has a result saved. If it does, it can return this saved result. Otherwise, it can calculate the result, add it to the dictionary, and return the result.</paragraph></list-item></list><list style=\"bullet\"/><paragraph/></document>"
    },
    {
      "id": 362114,
      "original_id": 340288,
      "lesson_id": 53336,
      "user_id": 93339,
      "course_id": 16645,
      "type": "code",
      "title": "Exercise 3: List mapper",
      "index": 5,
      "is_hidden": false,
      "lesson_markable_id": null,
      "rubric_id": null,
      "rubric_points": null,
      "auto_points": null,
      "status": "unseen",
      "correct": null,
      "response": null,
      "created_at": "2024-05-27T01:25:47.394393+10:00",
      "updated_at": null,
      "challenge_id": 119402,
      "content": "<document version=\"2.0\"><paragraph>Write a program in which you define a function <code>map()</code>, which takes a <bold>function</bold> and a <bold>list</bold> and applies the function to each element of the list, <bold>returning the results as a list</bold>.</paragraph><paragraph>Examples:</paragraph><pre>x = map(abs, [-2, 4, -6, -8])\nprint(x)\n[2, 4, 6, 8]\n</pre></document>"
    },
    {
      "id": 362115,
      "original_id": 340284,
      "lesson_id": 53336,
      "user_id": 93339,
      "course_id": 16645,
      "type": "code",
      "title": "Exercise 4: Roman numerals",
      "index": 6,
      "is_hidden": false,
      "lesson_markable_id": null,
      "rubric_id": null,
      "rubric_points": null,
      "auto_points": null,
      "status": "unseen",
      "correct": null,
      "response": null,
      "created_at": "2024-05-27T01:25:47.394393+10:00",
      "updated_at": null,
      "challenge_id": 119403,
      "content": "<document version=\"2.0\"><paragraph>Write a program that prints out the <bold>decimal</bold> value of a <bold>Roman numeral</bold>.</paragraph><paragraph>Your program should accept the Roman numeral from the <bold>command line arguments</bold>. Click on <bold>Terminal</bold> to activate the terminal. </paragraph><paragraph>You may assume the Roman numeral is in the \"<bold>standard</bold>\" form, i.e., any digits involving <bold>4</bold> and <bold>9</bold> will always appear in the <bold>subtractive form</bold>.</paragraph><heading level=\"2\">Sample interactions</heading><pre>python roman_numerals.py II\n2</pre><pre>python roman_numerals.py IV\n4</pre><pre>python roman_numerals.py IX\n9</pre><pre>python roman_numerals.py XIX\n19</pre><pre>python roman_numerals.py XX\n20</pre><pre>python roman_numerals.py MDCCLXXVI\n1776</pre><pre>python roman_numerals.py MMXIX\n2019</pre><paragraph>Hints:</paragraph><list style=\"bullet\"><list-item><paragraph>Use a loop to iterate through the Roman numeral to figure out their value.</paragraph></list-item><list-item><paragraph>Use a <bold>list of tuples</bold> to store the string characters and their respective values. Compare the characters from the input to this list.</paragraph></list-item><list-item><paragraph>Use a <code>while</code> loop so you can manually control the indices.</paragraph></list-item></list></document>"
    },
    {
      "id": 362116,
      "original_id": 326239,
      "lesson_id": 53336,
      "user_id": 93339,
      "course_id": 16645,
      "type": "code",
      "title": "Exercise 5: Finding particular sequences of prime numbers",
      "index": 7,
      "is_hidden": false,
      "lesson_markable_id": null,
      "rubric_id": null,
      "rubric_points": null,
      "auto_points": null,
      "status": "unseen",
      "correct": null,
      "response": null,
      "created_at": "2024-05-27T01:25:47.394393+10:00",
      "updated_at": null,
      "challenge_id": 119404,
      "content": "<document version=\"2.0\"><paragraph>Insert your code into <bold>consecutive_primes.py</bold> to find all <bold>sequences</bold> of <bold>6 consecutive prime 5-digit numbers</bold>, say $(a, b, c, d, e, f)$, with $b = a + 2$, $c = b + 4$, $d = c + 6$, $e = d + 8$, and $f = e + 10$.</paragraph><paragraph>$a$, $b$, $c$, $d$, $e$, and $f$ are therefore all <bold>5-digit prime numbers</bold> and <bold>no number</bold> between $a$ and $b$, between $b$ and $c$, between $c$ and $d$, between $d$ and $e$, and between $e$ and $f$ <bold>is prime</bold>.</paragraph><paragraph>If you are stuck, but only when you are stuck, then use <bold>consecutive_primes_scaffold.py</bold>.</paragraph></document>"
    },
    {
      "id": 362117,
      "original_id": 326240,
      "lesson_id": 53336,
      "user_id": 93339,
      "course_id": 16645,
      "type": "code",
      "title": "Exercise 6: Special products",
      "index": 8,
      "is_hidden": false,
      "lesson_markable_id": null,
      "rubric_id": null,
      "rubric_points": null,
      "auto_points": null,
      "status": "unseen",
      "correct": null,
      "response": null,
      "created_at": "2024-05-27T01:25:47.394393+10:00",
      "updated_at": null,
      "challenge_id": 119405,
      "content": "<document version=\"2.0\"><paragraph>Insert your code into <bold>special_products.py</bold> to find all <bold>triples</bold> of positive integers $(i, j, k)$ such that $i$, $j$, and $k$ are <bold>two digit numbers</bold>, no digit occurs more than once in $i$, $j$, and $k$, and the set of digits that occur in $i$, $j$, or $k$ is equal to the set of digits that occur in the product of $i$, $j$, and $k$.</paragraph><paragraph>If you are stuck, but only when you are stuck, then use <bold>special_products_scaffold_1.py</bold>. If you are still stuck, but only when you are still stuck, then use <bold>special_products_scaffold_2.py</bold>.</paragraph></document>"
    },
    {
      "id": 362118,
      "original_id": 326241,
      "lesson_id": 53336,
      "user_id": 93339,
      "course_id": 16645,
      "type": "code",
      "title": "Exercise 7: Finding particular sequences of triples of the form (n, n+1, n+2)",
      "index": 9,
      "is_hidden": false,
      "lesson_markable_id": null,
      "rubric_id": null,
      "rubric_points": null,
      "auto_points": null,
      "status": "unseen",
      "correct": null,
      "response": null,
      "created_at": "2024-05-27T01:25:47.394393+10:00",
      "updated_at": null,
      "challenge_id": 119406,
      "content": "<document version=\"2.0\"><paragraph>Write a program called <bold>special_triples.py</bold> that finds all <bold>triples</bold> of <bold>consecutive positive three-digit integers</bold> each of which is the <bold>sum of two squares</bold>, that is, all triples of the form $(n,n+1,n+2)$ such that:</paragraph><list style=\"bullet\"><list-item><paragraph>$n$, $n+1$ and $n+2$ are integers <bold>at least equal to 100</bold> and <bold>at most equal to 999</bold>;</paragraph></list-item><list-item><paragraph>each of $n$, $n+1$ and $n+2$ is of the form <bold>$a^2+b^2$</bold>.</paragraph></list-item></list><paragraph><bold>Hint:</bold> As we are not constrained by memory space for this problem, we might use a list that stores an integer for all indexes $n$ in $[100,999]$, equal to 1 in case $n$ is the sum of two squares, and to 0 otherwise. Then it is just a matter of finding three consecutive 1's in the list. This idea can be refined (by not storing 1s, but suitable nonzero values) to not only know that some number is of the form $a^2+b^2$, but also know such a pair $(a,b)$.</paragraph><paragraph>If an integer $n$ is of the form $a^2+b^2$, then the decomposition is not necessarily unique. We want each decomposition that is output to be the minimal one w.r.t. the natural ordering of pairs of integers (that is, $(a,b)&lt;(a',b')$ iff either $a&lt;a'$ or $a=a'$ and $b&lt;b'$).</paragraph><paragraph>If you are stuck, but only when you are stuck, then use <bold>special_triples_scaffold.py</bold>.</paragraph></document>"
    },
    {
      "id": 367850,
      "original_id": 362108,
      "lesson_id": 53336,
      "user_id": 93339,
      "course_id": 16645,
      "type": "code",
      "title": "Exercise 8: Number of trailing 0s in a factorial",
      "index": 99,
      "is_hidden": false,
      "lesson_markable_id": null,
      "rubric_id": null,
      "rubric_points": null,
      "auto_points": null,
      "status": "unseen",
      "correct": null,
      "response": null,
      "created_at": "2024-05-31T18:05:20.571752+10:00",
      "updated_at": null,
      "challenge_id": 121727,
      "content": "<document version=\"2.0\"><paragraph>To illustrate, <bold>15!</bold>, the factorial of 15, is equal to 1307674368<bold>000</bold>, hence has 3 <bold>trailing 0s</bold>.</paragraph><paragraph>There are at least <bold>three methods</bold> to compute the number of trailing 0s in the factorial of a number N at least equal to 5:</paragraph><list style=\"number\"><list-item><paragraph>Divide N! by 10 for as long as it yields no remainder. Note that for a positive integer x, x // 10 \"removes\" the rightmost digit from x, that digit being equal to x % 10.<break/></paragraph></list-item><list-item><paragraph>Convert N! into a string and find the rightmost occurrence of a character different to 0. A Google search, or executing dir(str) at the python prompt, suggests which string method to use. Note that negative indexes (-1 being the index of the last character in a string, -2 the index of the penultimate character in a string, etc.) is particularly convenient here.<break/></paragraph></list-item><list-item><paragraph>Python computes such huge numbers as 1000!, either iteratively multiplying all numbers from 1 up to 1000 or using factorial() from the math module (executing import math and then dir(math) at the python prompt confirms that this function is available), and the first two methods work for such numbers, but there is a much better method that operates on N rather N!, hence that does not suffer the limitations of the first two, and is very efficient. The number of trailing 0s in N! is equal to the number of times N! is a multiple of 10, so to the number of times N! is a multiple of 2 x 5. It is easy to verify that N! has at least as many multiples of 2 as multiples of 5. Hence the number of trailing 0s in N!</paragraph><list style=\"bullet\"><list-item><paragraph>is equal to the number of times N! is a multiple of 5</paragraph></list-item><list-item><paragraph>which is equal to the number of times 5 occurs in the prime decompositions of 1, 2, ..., N-1 and N</paragraph></list-item><list-item><paragraph>which is equal to the number of times 5 occurs at least once in the prime decompositions of 1, 2, ..., N-1 and N, plus the number of times 5 occurs at least twice in the prime decompositions of 1, 2, ..., N-1 and N, plus the number of times 5 occurs at least thrice in the prime decompositions of 1, 2, ..., N-1 and N...</paragraph></list-item><list-item><paragraph>which is equal to the number of multiples of 5 at most equal to N, plus the number of multiples of 5^2 at most equal to N, plus the number of multiples of 5^3 at most equal to N ...</paragraph></list-item></list></list-item></list><paragraph>Insert your code into <bold>trailing_0s_in_factorials.py</bold> so that the program prompts the user for a non-negative integer N. If the input is incorrect then the program outputs an error message and exits. Otherwise the program computes 5! three times, using the three methods just described. See sample outputs for details on input and ouput. If you are stuck, but only when you are stuck, then use <bold>trailing_0s_in_factorial_scaffold_1.py</bold>. If you are still stuck, but only when you are still stuck, then use <bold>trailing_0s_in_factorial_scaffold_2.py</bold>.</paragraph></document>"
    }
  ],
  "solutions_at": null,
  "state": "active",
  "status": "unattempted",
  "submitted_at": null,
  "timer_duration": 60,
  "timer_effective_duration": 60,
  "timer_expiration_access": false,
  "title": "Week 4",
  "tutorial_regex": "",
  "type": "python",
  "updated_at": null,
  "user_id": 93339
}