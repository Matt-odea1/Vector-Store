{
  "attempt_id": null,
  "attempted_at": null,
  "attempts": null,
  "attempts_remaining": null,
  "available_at": null,
  "clean_attempts": false,
  "course_id": 16645,
  "created_at": "2024-05-27T01:25:50.005439+10:00",
  "due_at": null,
  "effective_available_at": null,
  "effective_due_at": null,
  "effective_locked_at": null,
  "first_viewed_at": null,
  "grade_passback_auto_send": false,
  "grade_passback_mode": "",
  "grade_passback_scale_to": null,
  "id": 53340,
  "index": 7,
  "inverse_regex": false,
  "is_hidden": false,
  "is_timed": false,
  "is_unlisted": false,
  "kind": "content",
  "last_viewed_slide_id": null,
  "late_submissions": true,
  "locked_at": null,
  "module_id": 11529,
  "number": -1,
  "openable": false,
  "openable_without_attempt": false,
  "original_id": 47918,
  "outline": "",
  "password": "",
  "password_one_time": false,
  "prerequisites": [],
  "release_challenge_solutions": false,
  "release_challenge_solutions_while_active": true,
  "release_feedback": false,
  "release_feedback_while_active": false,
  "release_quiz_correctness_only": false,
  "release_quiz_solutions": false,
  "reopen_submissions": false,
  "require_user_override": false,
  "settings": {
    "quiz_question_number_style": "",
    "quiz_mode": "multiple-attempts",
    "quiz_active_status": "active"
  },
  "slide_count": 5,
  "slide_marks_summary": [
    {
      "id": 362134,
      "is_hidden": false,
      "rubric_points": 0,
      "auto_points": 3,
      "scoring_mode": "",
      "scale_to": null,
      "scale_to_auto": null,
      "scale_to_rubric": null
    },
    {
      "id": 362135,
      "is_hidden": false,
      "rubric_points": 0,
      "auto_points": 0,
      "scoring_mode": "",
      "scale_to": null,
      "scale_to_auto": null,
      "scale_to_rubric": null
    },
    {
      "id": 362136,
      "is_hidden": false,
      "rubric_points": 0,
      "auto_points": 0,
      "scoring_mode": "",
      "scale_to": null,
      "scale_to_auto": null,
      "scale_to_rubric": null
    },
    {
      "id": 378432,
      "is_hidden": false,
      "rubric_points": 0,
      "auto_points": 0,
      "scoring_mode": "",
      "scale_to": null,
      "scale_to_auto": null,
      "scale_to_rubric": null
    },
    {
      "id": 381773,
      "is_hidden": false,
      "rubric_points": 0,
      "auto_points": 0,
      "scoring_mode": "",
      "scale_to": null,
      "scale_to_auto": null,
      "scale_to_rubric": null
    }
  ],
  "slides": [
    {
      "id": 362134,
      "original_id": 326259,
      "lesson_id": 53340,
      "user_id": 93339,
      "course_id": 16645,
      "type": "code",
      "title": "Exercise 1: Canonical coin systems",
      "index": 2,
      "is_hidden": false,
      "lesson_markable_id": null,
      "rubric_id": null,
      "rubric_points": null,
      "auto_points": null,
      "status": "unseen",
      "correct": null,
      "response": null,
      "created_at": "2024-05-27T01:25:50.005439+10:00",
      "updated_at": null,
      "challenge_id": 119422,
      "content": "<document version=\"2.0\"><paragraph>Write a program that prompts the user for an amount, and outputs the minimal number of coins needed to yield that amount, as well as the detail of how many coins of each value are used. The available coins have a face value which is one of \\$1, \\$2, \\$5, \\$10, \\$20, \\$50, and \\$100.</paragraph><paragraph>Insert your code into <code>canonical_coin_systems.py</code>.</paragraph><paragraph>Here are examples of interactions: </paragraph><pre>$ python3 canonical_coin_systems.py\r\nInput the desired amount: 10\r\n\n1 banknote is needed.\r\nThe detail is:\r\n$10: 1\r\n\n$ python3 canonical_coin_systems.py\r\nInput the desired amount: 739\r\n\n12 banknotes are needed\r\nThe detail is:\r\n$100: 7\r\n $20: 1\r\n $10: 1\r\n  $5: 1\r\n  $2: 2\r\n\n$ python3 canonical_coin_systems.py\r\nInput the desired amount: 35642\r\n\n359 banknotes are needed\r\nThe detail is:\r\n$100: 356\r\n $20: 2\r\n  $2: 1\r\n</pre></document>"
    },
    {
      "id": 362135,
      "original_id": 326256,
      "lesson_id": 53340,
      "user_id": 93339,
      "course_id": 16645,
      "type": "code",
      "title": "Exercise 2: Unit fractions",
      "index": 3,
      "is_hidden": false,
      "lesson_markable_id": null,
      "rubric_id": null,
      "rubric_points": null,
      "auto_points": null,
      "status": "unseen",
      "correct": null,
      "response": null,
      "created_at": "2024-05-27T01:25:50.005439+10:00",
      "updated_at": null,
      "challenge_id": 119423,
      "content": "<document version=\"2.0\"><paragraph>Let $N$ and $D$ be two strictly positive integers with $N&lt;D$. The fraction $N/D$ can be written as a sum of unit fractions, that is, there exists integers $k,d_1,\\ldots,d_k\\geq 1$ with $d_1&lt;d_2&lt;\\ldots&lt;d_k$ such that</paragraph><paragraph>$\\frac{N}{D} = \\frac{1}{d_1}+\\frac{1}{d_2}+\\dots+\\frac{1}{d_k}$.</paragraph><paragraph>There are actually infinitely many such representations. Indeed, since</paragraph><paragraph>$1=\\frac{1}{2}+\\frac{1}{3}+\\frac{1}{6}$</paragraph><paragraph>if $\\frac{N}{D} = \\frac{1}{d_1}+\\frac{1}{d_2}+\\dots+\\frac{1}{d_k}$ then also</paragraph><paragraph>$\\frac{N}{D} = \\frac{1}{d_1}+\\frac{1}{d_2}+\\dots+\\frac{1}{d_{k-1}}+\\frac{1}{2d_k}+\\frac{1}{3d_k}+\\frac{1}{6d_k}$.</paragraph><paragraph><break/>One particular representation is obtained by a method proposed by Fibonacci, in the form of a greedy algorithm. Suppose that $N/D$ cannot be simplified, that is, $N$ and $D$ have no other common factor but 1. If $N=1$ then we are done, so suppose otherwise. Let $d_1$ be the smallest integer such that $\\frac{N}{D}$ can be written as $\\frac{1}{d_1}+f_1$, with $f_1$ necessarily strictly positive by assumption. Looking for the smallest $d_1$ is what makes the algorithm greedy. Of course, $d_1$ is equal to $D\\div N + 1$. By the choice of $d_1$, $\\frac{1}{d_1-1}&gt;\\frac{N}{D}$, hence $D&gt;N(d_1-1)$, hence $N&gt;Nd_1-D$. Since $f_1$ is equal to $\\frac{N}{D}-\\frac{1}{d_1}=\\frac{Nd_1-D}{Dd_1}$, it follows that $\\frac{N}{D}$ can be written as $\\frac{1}{d_1}+\\frac{N_1}{D_1}$ with $N_1&lt;N$. If $N_1&gt;1$ then the same argument allows one to greedily find $d_2&gt;d_1$ such that for some strictly positive integers $N_2$ and $D_2$, $\\frac{N}{D}$ can be written as $\\frac{1}{d_1}+\\frac{1}{d_2}+\\frac{N_2}{D_2}$ with $N_2&lt;N_1$, and if $N_2&gt;1$ then the same argument allows one to greedily find $d_3&gt;d_2$ such that for some strictly positive integers $N_3$ and $D_3$, $\\frac{N}{D}$ can be written as $\\frac{1}{d_1}+\\frac{1}{d_2}+\\frac{1}{d_3}+\\frac{N_3}{D_3}$ with $N_3&lt;N_2$... After a finite number of steps, we are done.</paragraph><paragraph>The number of summands in the sum of unit fractions given by Fibonacci's method is not always minimal: it is sometimes possible to decompose $\\frac{N}{D}$ as sum of unit fractions with fewer summands. For instance, Fibonacci's method yields</paragraph><paragraph>$\\frac{4}{17} = \\frac{1}{5} + \\frac{1}{29} + \\frac{1}{1233} + \\frac{1}{3039345}$</paragraph><paragraph>whereas $\\frac{4}{17}$ can be written as a sum of 3 unit fractions, actually in 4 possible ways:</paragraph><list style=\"bullet\"><list-item><paragraph>$\\frac{4}{17} = \\frac{1}{5} + \\frac{1}{30} + \\frac{1}{510}$</paragraph></list-item><list-item><paragraph>$\\frac{4}{17} = \\frac{1}{5} + \\frac{1}{34} + \\frac{1}{170}$</paragraph></list-item><list-item><paragraph>$\\frac{4}{17} = \\frac{1}{6} + \\frac{1}{15} + \\frac{1}{510}$</paragraph></list-item><list-item><paragraph>$\\frac{4}{17} = \\frac{1}{6} + \\frac{1}{17} + \\frac{1}{102}$</paragraph></list-item></list><paragraph/><paragraph>Complete the program <code>unit_fractions.py</code> so as to have the functionality of the two functions:</paragraph><list style=\"bullet\"><list-item><paragraph><code>fibonacci_decomposition(N, D)</code>, that takes two strictly positive integers $N$ and $D$ as arguments, and writes $N/D$ as a sum of unit fractions following Fibonacci method, plus an integer in case $N ≥ D$ (in a unique way)</paragraph></list-item><list-item><paragraph><code>shortest_length_decompositions(N, D)</code>, that also takes two strictly positive integers $N$ and $D$ as arguments, and writes $N/D$ as a sum of unit fractions with a minimal number of summands, plus an integer in case N ≥ D (in possibly many ways)</paragraph></list-item></list><paragraph/><paragraph>Here are possible interactions:</paragraph><pre> &gt;&gt;&gt; from unit_fractions import *\n &gt;&gt;&gt; fibonacci_decomposition(1, 521)\n 1/521 = 1/521\n &gt;&gt;&gt; fibonacci_decomposition(521, 521)\n 521/521 = 1\n &gt;&gt;&gt; fibonacci_decomposition(521, 1050)\n 521/1050 = 1/3 + 1/7 + 1/50\n &gt;&gt;&gt; fibonacci_decomposition(1050, 521)\n 1050/521 = 2 + 1/66 + 1/4913 + 1/33787684 + 1/2854018941421956\n &gt;&gt;&gt; fibonacci_decomposition(6, 7)\n 6/7 = 1/2 + 1/3 + 1/42\n &gt;&gt;&gt; shortest_length_decompositions(6, 7)\n 6/7 = 1/2 + 1/3 + 1/42\n &gt;&gt;&gt; fibonacci_decomposition(8, 11)\n 8/11 = 1/2 + 1/5 + 1/37 + 1/4070\n &gt;&gt;&gt; shortest_length_decompositions(8, 11)\n 8/11 = 1/2 + 1/5 + 1/37 + 1/4070\n 8/11 = 1/2 + 1/5 + 1/38 + 1/1045\n 8/11 = 1/2 + 1/5 + 1/40 + 1/440\n 8/11 = 1/2 + 1/5 + 1/44 + 1/220\n 8/11 = 1/2 + 1/5 + 1/45 + 1/198\n 8/11 = 1/2 + 1/5 + 1/55 + 1/110\n 8/11 = 1/2 + 1/5 + 1/70 + 1/77\n 8/11 = 1/2 + 1/6 + 1/17 + 1/561\n 8/11 = 1/2 + 1/6 + 1/18 + 1/198\n 8/11 = 1/2 + 1/6 + 1/21 + 1/77\n 8/11 = 1/2 + 1/6 + 1/22 + 1/66\n 8/11 = 1/2 + 1/7 + 1/12 + 1/924\n 8/11 = 1/2 + 1/7 + 1/14 + 1/77\n 8/11 = 1/2 + 1/8 + 1/10 + 1/440\n 8/11 = 1/2 + 1/8 + 1/11 + 1/88\n 8/11 = 1/3 + 1/4 + 1/7 + 1/924\n &gt;&gt;&gt; fibonacci_decomposition(4, 17)\n 4/17 = 1/5 + 1/29 + 1/1233 + 1/3039345\n &gt;&gt;&gt; shortest_length_decompositions(4, 17)\n 4/17 = 1/5 + 1/30 + 1/510\n 4/17 = 1/5 + 1/34 + 1/170\n 4/17 = 1/6 + 1/15 + 1/510\n 4/17 = 1/6 + 1/17 + 1/102 \n</pre></document>"
    },
    {
      "id": 362136,
      "original_id": 326257,
      "lesson_id": 53340,
      "user_id": 93339,
      "course_id": 16645,
      "type": "code",
      "title": "Exercise 3: Diophantine equations",
      "index": 4,
      "is_hidden": false,
      "lesson_markable_id": null,
      "rubric_id": null,
      "rubric_points": null,
      "auto_points": null,
      "status": "unseen",
      "correct": null,
      "response": null,
      "created_at": "2024-05-27T01:25:50.005439+10:00",
      "updated_at": null,
      "challenge_id": 119424,
      "content": "<document version=\"2.0\"><paragraph>We consider Diophantine equations of the form $ax+by=c$ with $a$ and $b$ both not equal to 0. We will represent such an equation as a string of the form ax+by=c or ax-by=c where a and c are nonzero integer literals (not preceded by + in case they are positive) and where b is a strictly positive integer literal (not preceded by +), possibly with spaces anywhere at the beginning, at the end, and around the +, - and = characters. The equation $ax+by=c$ has a solution iff $c$ is a multiple of $\\gcd(a,b)$. In case $c$ is indeed a multiple of $\\gcd(a,b)$, then $ax+by=c$ has has infinitely many solutions, namely, all pairs $(x,y)$ of the form</paragraph><paragraph><break/>$\\left(x_0 + \\frac{\\mathrm{lcm}(a,b)}{a}n,y_0 - \\frac{\\mathrm{lcm}(a,b)}{b}n\\right)$</paragraph><paragraph><break/>for arbitrary integers $n$, where $\\mathrm{lcm}(a,b)$ denotes the least common multiplier of $a$ and $b$, and where $(x_0,y_0)$ is a solution to the equation. That particular solution can be derived from the extended Euclidian algorithm, that yields not only $\\gcd(a,b)$ but also a pair of Bézout coefficients, namely, two integers $x$ and $y$ with $ax+by=\\gcd(a,b)$. To normalise the representation of the solutions, we rewrite the equation above as<break/><break/>$\\left(x_0 + \\frac{\\mathrm{lcm}(a,b)}{|a|}n,y_0 - \\mathrm{sign}(a)\\frac{\\mathrm{lcm}(a,b)}{b}n\\right)$<break/><break/>where $\\mathrm{sign}(a)$ is 1 if $a$ is positive and -1 if $a$ is negative, and we impose that the pair $(x_0,y_0)$ is such that $x_0$ is nonnegative and minimal.</paragraph><paragraph>Write a Python program <code>diophantine_equation.py</code> that defines a function <code>diophantine()</code> that prints out whether the equation provided as argument has a solution, and in case it does, prints out the normalised representation of its solutions. The output reproduces the equation nicely formatted, that is, with a single space around the <code><bold>+</bold></code>, <code><bold>-</bold></code> and <code><bold>=</bold></code> characters. As for the representation of the solutions, it is also nicely formatted, omitting $x_0$ or $y_0$ when they are equal to 0, and omitting 1 as a factor of $n$. Press the <bold>Run</bold> or <bold>Mark</bold> buttons for possible interactions:</paragraph><pre>&gt;&gt;&gt; diophantine('1x + 1y = 0')\n1x + 1y = 0 has as solutions all pairs of the form\n    (n, -n) with n an arbitrary integer.\n&gt;&gt;&gt; diophantine('-1x + 1y = 0')\n-1x + 1y = 0 has as solutions all pairs of the form\n    (n, n) with n an arbitrary integer.\n&gt;&gt;&gt; diophantine('1x - 1y = 0')\n1x - 1y = 0 has as solutions all pairs of the form\n    (n, n) with n an arbitrary integer.\n&gt;&gt;&gt; diophantine('-1x - 1y = 0')\n-1x - 1y = 0 has as solutions all pairs of the form\n    (n, -n) with n an arbitrary integer.\n&gt;&gt;&gt; diophantine('1x + 1y = -1')\n1x + 1y = -1 has as solutions all pairs of the form\n    (n, -1 - n) with n an arbitrary integer.\n&gt;&gt;&gt; diophantine('-1x + 1y = 1')\n-1x + 1y = 1 has as solutions all pairs of the form\n    (n, 1 + n) with n an arbitrary integer.\n&gt;&gt;&gt; diophantine('4x + 6y = 9')\n4x + 6y = 9 has no solution.\n&gt;&gt;&gt; diophantine('4x + 6y = 10')\n4x + 6y = 10 has as solutions all pairs of the form\n    (1 + 3n, 1 - 2n) with n an arbitrary integer.\n&gt;&gt;&gt; diophantine('71x+83y=2')\n71x + 83y = 2 has as solutions all pairs of the form\n    (69 + 83n, -59 - 71n) with n an arbitrary integer.\n&gt;&gt;&gt; diophantine(' 782 x + 253 y = 92')\n782x + 253y = 92 has as solutions all pairs of the form\n    (4 + 11n, -12 - 34n) with n an arbitrary integer.\n&gt;&gt;&gt; diophantine('-123x -456y = 78')\n-123x - 456y = 78 has as solutions all pairs of the form\n    (118 + 152n, -32 - 41n) with n an arbitrary integer.\n&gt;&gt;&gt; diophantine('-321x +654y = -87')\n-321x + 654y = -87 has as solutions all pairs of the form\n    (149 + 218n, 73 + 107n) with n an arbitrary integer.\n</pre><paragraph/></document>"
    },
    {
      "id": 378432,
      "original_id": 362140,
      "lesson_id": 53340,
      "user_id": 93339,
      "course_id": 16645,
      "type": "code",
      "title": "Exercise 4: Fibonacci codes",
      "index": 6,
      "is_hidden": false,
      "lesson_markable_id": null,
      "rubric_id": null,
      "rubric_points": null,
      "auto_points": null,
      "status": "unseen",
      "correct": null,
      "response": null,
      "created_at": "2024-06-29T12:51:31.494009+10:00",
      "updated_at": null,
      "challenge_id": 124978,
      "content": "<document version=\"2.0\"><paragraph>Recall that the Fibonacci sequence $(F_n)_{n&gt;=0}$ is defined by the equations: $F_0=0$, $F_1=1$ and for all $n&gt;0$, $F_n=F_{n+1}+F_{n-2}$.</paragraph><paragraph>It can be shown that every strictly positive integer $N$ can be uniquely coded as a string $\\sigma$ of 0's and 1's ending with 1, so of the form $b_2b_3\\ldots b_k$ with $k\\geq 2$ and $b_k=1$, such that $N$ is the sum of all $F_i$'s, $2\\leq i\\leq k$, with $b_i=1$.</paragraph><paragraph>For instance, $11=3+8=F_4+F_6$, hence 11 is coded by 00101.</paragraph><paragraph>Moreover:</paragraph><list style=\"bullet\"><list-item><paragraph>there are no two successive occurrences of 1 in $\\sigma$;</paragraph></list-item><list-item><paragraph>$F_k$ is the largest Fibonacci number that fits in $N$, and if $j$ is the largest integer in $\\{2,\\ldots,k-1\\}$ such that $b_j=1$ then $F_j$ is the largest Fibonacci number that fits in $N-F_k$, and if $i$ is the largest integer in $\\{2,\\ldots,j-1\\}$ such that $b_i=1$ then $F_i$ is the largest Fibonacci number that fits in $N-F_k-F_j$...</paragraph></list-item></list><paragraph>Also, every string of 0's and 1's ending in 1 and having no two successive occurrences of 1's is a code of a strictly positive integer according to this coding scheme. For instance:</paragraph><list style=\"bullet\"><list-item><paragraph>There is only one string of 0's and 1's of length 1 ending in 1 and having no two successive occurrences of 1's; it is 1, and it codes 1.</paragraph></list-item><list-item><paragraph>There is only one string of 0's and 1's of length 2 ending in 1 and having no two successive occurrences of 1's; it is 01, and it codes 2.</paragraph></list-item><list-item><paragraph>The strings of 0's and 1's of length 3 ending in 1 and having no two successive occurrences of 1's are 001 and 101 and they code 3 and 4, respectively.</paragraph></list-item><list-item><paragraph>The strings of 0's and 1's of length 4 ending in 1 and having no two successive occurrences of 1's are 0001, 1001 and 0101 and they code 5, 6 and 7, respectively.</paragraph></list-item><list-item><paragraph>The strings of 0's and 1's of length 5 ending in 1 and having no two successive occurrences of 1's are 00001, 10001, 01001, 00101 and 10101 and they code 8, 9, 10, 11 and 12, respectively.</paragraph></list-item><list-item><paragraph>...</paragraph></list-item></list><paragraph>The Fibonacci code of $N$ adds 1 at the end of $\\sigma$; the resulting string then ends in two 1's, therefore marking the end of the code, and allowing one to let one string code a finite sequence of strictly positive integers. For instance, 00101100111011 codes $(11,3,4)$.</paragraph><paragraph>Implement the two functions in the stub, one that takes one argument $N$ mean to to be a strictly positive integer and returns its Fibonacci code, and one that takes one argument $\\sigma$ meant to be a strict consisting 0's and 1's, returns 0 if $\\sigma$ cannot be a Fibonacci code, and otherwise returns the integer $\\sigma$ is the Fibonacci code of.</paragraph><paragraph>Here are possible interactions:</paragraph><pre>$ python3\n...\n&gt;&gt;&gt; from fibonacci_codes import *\n&gt;&gt;&gt; encode(1)\n’11’\n&gt;&gt;&gt; encode(2)\n’011’\n&gt;&gt;&gt; encode(3)\n’0011’\n&gt;&gt;&gt; encode(4)\n’1011’\n&gt;&gt;&gt; encode(8)\n’000011’\n&gt;&gt;&gt; encode(11)\n’001011’\n&gt;&gt;&gt; encode(12)\n’101011’\n&gt;&gt;&gt; encode(14)\n’1000011’\n&gt;&gt;&gt; decode(’1’)\n0\n&gt;&gt;&gt; decode(’01’)\n0\n&gt;&gt;&gt; decode(’100011011’)\n0\n&gt;&gt;&gt; decode(’11’)\n1\n&gt;&gt;&gt; decode(’011’)\n2\n&gt;&gt;&gt; decode(’0011’)\n3\n&gt;&gt;&gt; decode(’1011’)\n4\n&gt;&gt;&gt; decode(’000011’)\n8\n&gt;&gt;&gt; decode(’001011’)\n11\n&gt;&gt;&gt; decode(’1000011’)\n14\n</pre></document>"
    },
    {
      "id": 381773,
      "original_id": 362138,
      "lesson_id": 53340,
      "user_id": 93339,
      "course_id": 16645,
      "type": "code",
      "title": "Exercise 5: Change making",
      "index": 7,
      "is_hidden": false,
      "lesson_markable_id": null,
      "rubric_id": null,
      "rubric_points": null,
      "auto_points": null,
      "status": "unseen",
      "correct": null,
      "response": null,
      "created_at": "2024-07-10T19:35:31.121127+10:00",
      "updated_at": null,
      "challenge_id": 126100,
      "content": "<document version=\"2.0\"><paragraph>Write a program <code>change_making.py</code> that <bold>prompts</bold> the user for the <bold>face values of coins</bold> and their associated <bold>quantities</bold> as well as for an <bold>amount</bold>, and if possible, <bold>outputs</bold> the <bold>minimal number of coins</bold> needed to <bold>match that amount</bold>, as well as the <bold>detail of how many coins of each type value are used</bold>.</paragraph><paragraph>The face values and associated quantities should be input as a <bold>dictionary</bold>. You might find the <code>literal_eval()</code> function from the <code>ast</code> module to be useful.</paragraph><paragraph>A solution is output from smallest face value to largest face value. If a solution is represented as a list of pairs of the form (coin face value, number of coins) ordered from smallest to largest face value, then the solutions themselves are output in lexicographical order (for sequences of pairs). All face values for a given solution are right aligned.</paragraph><paragraph>Insert your code into <code>change_making.py</code>.</paragraph><paragraph>Here are examples of interactions:</paragraph><pre>$ python3 change_making.py\nInput a dictionary whose keys represent coin face values\nwith as value for a given key the number of coins\nthat are available for the corresponding face value:\n    {2: 100, 50: 100}\nInput the desired amount: 99\n\nThere is no solution.\n\n$ python3 change_making.py\nInput a dictionary whose keys represent coin face values\nwith as value for a given key the number of coins \nthat are available for the corresponding face value:\n    {1: 30, 20: 30, 50: 30}\nInput the desired amount: 60\n\nThere is a unique solution:\n$20: 3\n\n$ python3 change_making.py\nInput a dictionary whose keys represent coin face values\nwith as value for a given key the number of coins\nthat are available for the corresponding face value:\n    {1: 100, 2: 5, 3: 4, 10: 5, 20: 4, 30: 1}\nInput the desired amount: 107\n\nThere are 2 solutions:\n$1: 1\n$3: 2\n$10: 1\n$20: 3\n$30: 1\n\n$2: 2\n$3: 1\n$10: 1\n$20: 3\n$30: 1\n\n$ python3 change_making.py\nInput a dictionary whose keys represent coins face values\nwith as value for a given key the number of coins\nthat are available for the corresponding face value:\n    {1: 7, 2: 5, 3: 4, 4: 3, 5: 2}\nInput the desired amount: 29\n\nThere are 4 solutions:\n$1: 1\n$3: 2\n$4: 3\n$5: 2\n\n$2: 1\n$3: 3\n$4: 2\n$5: 2\n\n$2: 2\n$3: 1\n$4: 3\n$5: 2\n\n$3: 4\n$4: 3\n$5: 1\n\n$ python3 change_making.py\nInput a dictionary whose keys represent coins face values\nwith as value for a given key the number of coins \nthat are available for the corresponding face value:\n    {11:34, 12:34, 13: 234, 17:44, 18:54, 19: 3}\nInput the desired amount: 3422\n\nThere are 8 solutions:\n$11: 1\n$12: 4\n$13: 122\n$17: 44\n$18: 54\n$19: 3\n\n$11: 1\n$13: 127\n$17: 43\n$18: 54\n$19: 3\n\n$11: 2\n$12: 2\n$13: 123\n$17: 44\n$18: 54\n$19: 3\n\n$11: 3\n$13: 124\n$17: 44\n$18: 54\n$19: 3\n\n$12: 1\n$13: 127\n$17: 44\n$18: 53\n$19: 3\n\n$12: 2\n$13: 126\n$17: 43\n$18: 54\n$19: 3\n\n$12: 6\n$13: 121\n$17: 44\n$18: 54\n$19: 3\n\n$13: 128\n$17: 44\n$18: 54\n$19: 2\n\n</pre><paragraph>The natural approach makes use of the <bold>linear programming</bold> technique exemplified in the computation of the <bold>Levenshtein distance</bold> between two words discussed in Week 9 lectures.</paragraph></document>"
    }
  ],
  "solutions_at": null,
  "state": "active",
  "status": "unattempted",
  "submitted_at": null,
  "timer_duration": 60,
  "timer_effective_duration": 60,
  "timer_expiration_access": false,
  "title": "Week 9",
  "tutorial_regex": "",
  "type": "python",
  "updated_at": null,
  "user_id": 93339
}