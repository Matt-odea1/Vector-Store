{
  "attempt_id": null,
  "attempted_at": null,
  "attempts": null,
  "attempts_remaining": null,
  "available_at": null,
  "clean_attempts": false,
  "course_id": 16645,
  "created_at": "2024-05-27T01:25:37.526309+10:00",
  "due_at": null,
  "effective_available_at": null,
  "effective_due_at": null,
  "effective_locked_at": null,
  "first_viewed_at": "2025-09-18T14:41:47.469366+10:00",
  "grade_passback_auto_send": false,
  "grade_passback_mode": "",
  "grade_passback_scale_to": null,
  "id": 53307,
  "index": 5,
  "inverse_regex": false,
  "is_hidden": false,
  "is_timed": false,
  "is_unlisted": false,
  "kind": "content",
  "last_viewed_slide_id": 361961,
  "late_submissions": true,
  "locked_at": null,
  "module_id": 11528,
  "number": -1,
  "openable": false,
  "openable_without_attempt": false,
  "original_id": 47895,
  "outline": "",
  "password": "",
  "password_one_time": false,
  "prerequisites": [],
  "release_challenge_solutions": false,
  "release_challenge_solutions_while_active": false,
  "release_feedback": false,
  "release_feedback_while_active": false,
  "release_quiz_correctness_only": false,
  "release_quiz_solutions": false,
  "reopen_submissions": false,
  "require_user_override": false,
  "settings": {
    "quiz_question_number_style": "",
    "quiz_mode": "multiple-attempts",
    "quiz_active_status": "active"
  },
  "slide_count": 8,
  "slide_marks_summary": [
    {
      "id": 361960,
      "is_hidden": false,
      "rubric_points": 0,
      "auto_points": 0,
      "scoring_mode": "",
      "scale_to": null,
      "scale_to_auto": null,
      "scale_to_rubric": null
    },
    {
      "id": 361961,
      "is_hidden": false,
      "rubric_points": 0,
      "auto_points": 0,
      "scoring_mode": "",
      "scale_to": null,
      "scale_to_auto": null,
      "scale_to_rubric": null
    },
    {
      "id": 361962,
      "is_hidden": false,
      "rubric_points": 0,
      "auto_points": 0,
      "scoring_mode": "",
      "scale_to": null,
      "scale_to_auto": null,
      "scale_to_rubric": null
    },
    {
      "id": 361963,
      "is_hidden": false,
      "rubric_points": 0,
      "auto_points": 0,
      "scoring_mode": "",
      "scale_to": null,
      "scale_to_auto": null,
      "scale_to_rubric": null
    },
    {
      "id": 361964,
      "is_hidden": false,
      "rubric_points": 0,
      "auto_points": 0,
      "scoring_mode": "",
      "scale_to": null,
      "scale_to_auto": null,
      "scale_to_rubric": null
    },
    {
      "id": 361965,
      "is_hidden": false,
      "rubric_points": 0,
      "auto_points": 0,
      "scoring_mode": "",
      "scale_to": null,
      "scale_to_auto": null,
      "scale_to_rubric": null
    },
    {
      "id": 361966,
      "is_hidden": false,
      "rubric_points": 0,
      "auto_points": 0,
      "scoring_mode": "",
      "scale_to": null,
      "scale_to_auto": null,
      "scale_to_rubric": null
    },
    {
      "id": 361967,
      "is_hidden": false,
      "rubric_points": 0,
      "auto_points": 0,
      "scoring_mode": "",
      "scale_to": null,
      "scale_to_auto": null,
      "scale_to_rubric": null
    }
  ],
  "slides": [
    {
      "id": 361960,
      "original_id": 340490,
      "lesson_id": 53307,
      "user_id": 93339,
      "course_id": 16645,
      "type": "document",
      "title": "Functions",
      "index": 157,
      "is_hidden": false,
      "lesson_markable_id": null,
      "rubric_id": null,
      "rubric_points": null,
      "auto_points": null,
      "status": "completed",
      "correct": null,
      "response": null,
      "created_at": "2024-05-27T01:25:37.526309+10:00",
      "updated_at": null,
      "content": "<document version=\"2.0\"><paragraph>Suppose you&#39;d like to print lists of things in the following &#39;smart&#39; way, which takes into account the number of items and uses commas and &#39;and&#39; accordingly:</paragraph><pre>A\nA and B\nA, B, and C\nA, B, C, and D\n</pre><paragraph>You can&#39;t just use the <code>join()</code> method of a string, because it doesn&#39;t do this. You have to write a piece of code. And the code required is reasonably complicated:</paragraph><snippet language=\"py\" runnable=\"false\" line-numbers=\"true\"><snippet-file id=\"code\"># Print the list &#39;lst&#39; in a smart way\nif len(lst) == 1:\n    print(lst[0])\nelif len(lst) == 2:\n    print(lst[0] + &#39; and &#39; + lst[1])\nelse:\n    print(&#39;, &#39;.join(lst[:-1]) + &#39;, and &#39; + lst[-1])</snippet-file></snippet><paragraph>Having to write this code every time you want to smart-print a list would be a pain. Also, if you find an error in the code, or if you think of a way to improve it, you&#39;ll have to find all instances of the code and update them one-by-one.</paragraph><paragraph>Fortunately, there is a <underline>much</underline> better way, and that&#39;s to define a <bold>function</bold> which does this smart printing. Then whenever you want to smart-print a list you can just call the function and provide it with the list.</paragraph><paragraph>Here&#39;s how your program might look (don&#39;t worry if you don&#39;t understand the &#34;def&#34; part - you&#39;ll be learning this):</paragraph><snippet language=\"py\" runnable=\"true\" line-numbers=\"true\"><snippet-file id=\"code\"># Define the function\ndef smart_print(lst):\n    if len(lst) == 1:\n        print(lst[0])\n    elif len(lst) == 2:\n        print(lst[0] + &#39; and &#39; + lst[1])\n    else:\n        print(&#39;, &#39;.join(lst[:-1]) + &#39;, and &#39; + lst[-1])\n\n# Use it\nsmart_print([&#39;A&#39;])\nsmart_print([&#39;A&#39;, &#39;B&#39;])\nsmart_print([&#39;A&#39;, &#39;B&#39;, &#39;C&#39;])\nsmart_print([&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;])</snippet-file></snippet><paragraph>This is much better. If you find an error in the code you only need to fix it in one place. If you think of a way to improve it, you only need to improve it in one place. And, as a bonus, the function name itself makes your code more self-documenting - each time you invoke the function its name makes it clear what you are doing, with no need for any comments. Brilliant!</paragraph><paragraph>Defining and using functions in this way is an example of <bold>code modularisation</bold>. It is an important and powerful technique, and is one of the cornerstones of good programming. You&#39;ll learn how to do it this week.</paragraph><paragraph></paragraph></document>"
    },
    {
      "id": 361961,
      "original_id": 340491,
      "lesson_id": 53307,
      "user_id": 93339,
      "course_id": 16645,
      "type": "document",
      "title": "Defining functions",
      "index": 158,
      "is_hidden": false,
      "lesson_markable_id": null,
      "rubric_id": null,
      "rubric_points": null,
      "auto_points": null,
      "status": "completed",
      "correct": null,
      "response": null,
      "created_at": "2024-05-27T01:25:37.526309+10:00",
      "updated_at": null,
      "content": "<document version=\"2.0\"><paragraph>So far you&#39;ve been using functions that are built-in to Python, such as <code>input()</code> , <code>print()</code>, and <code>len()</code>. Like many other languages, Python allows you to define your own functions.</paragraph><heading level=\"2\">Defining a function</heading><paragraph>You can define a function using a <code>def</code> statement, which has the following form:</paragraph><pre>def &lt;name&gt;():\n    &lt;statements&gt;</pre><paragraph>For example:</paragraph><snippet language=\"py\" runnable=\"true\" line-numbers=\"true\"><snippet-file id=\"code\">def say_hello():\n    print(&#39;Hello&#39;)</snippet-file></snippet><paragraph>Once you&#39;ve defined the function you can call it like any other function:</paragraph><snippet language=\"py\" runnable=\"true\" line-numbers=\"true\"><snippet-file id=\"code\">def say_hello():\n&#x9;print(&#39;Hello&#39;)\n\nsay_hello()</snippet-file></snippet><paragraph>Notice that the code inside the body of the function is not executed when the function is defined - it is only executed when the function is called.</paragraph><paragraph>Also notice that you must define the function before calling it:</paragraph><snippet line-numbers=\"true\" language=\"py\" runnable=\"true\"><snippet-file id=\"code\">say_hello() # Error - the function has not yet been defined\ndef say_hello():\n&#x9;print(&#39;Hello&#39;)</snippet-file></snippet><heading level=\"2\">Naming functions</heading><paragraph>The rules for naming functions are the same as for naming variables.</paragraph><paragraph>Although it is not required, it has become conventional to use snake case - lower case words, separated by underscores, for example <code>say_hello</code>.</paragraph><paragraph>You should choose names that help to document your code - naming the above function <code>say_hello</code>, for example, is more explanatory than naming it <code>hello</code>, or, even worse, <code>my_func</code>.</paragraph><heading level=\"2\">Adding parameters</heading><paragraph>You can add <bold>parameters</bold> to a function, to specify that the function should receive one or more <bold>arguments</bold> when it is called. You do this by adding parameter names in the brackets after the function name:</paragraph><snippet line-numbers=\"true\" language=\"py\" runnable=\"true\"><snippet-file id=\"code\">def say_hello(name): # Add a parameter called &#34;name&#34;\n&#x9;print(&#39;Hello,&#39;, name)\n\nsay_hello(&#39;James&#39;) # Provide &#39;James&#39; as an argument</snippet-file></snippet><paragraph>When you call a function you must supply it with the right number of arguments - one for each parameter.  If the function has no parameters then you must supply no arguments; if the function has one parameter then you must supply exactly one argument; and so on. If you supply the wrong number of arguments then Python will raise an error. The <code>say_hello()</code> function defined above has one parameter, so you must supply it with exactly one argument:</paragraph><snippet language=\"py\" runnable=\"true\" line-numbers=\"true\"><snippet-file id=\"code\">def say_hello(name):\n&#x9;print(&#39;Hello,&#39;, name)\n    \nsay_hello() # Error - not enough arguments</snippet-file></snippet><snippet language=\"py\" runnable=\"true\" line-numbers=\"true\"><snippet-file id=\"code\">def say_hello(name):\n&#x9;print(&#39;Hello,&#39;, name)\n    \nsay_hello(&#39;James&#39;, &#39;Sarah&#39;) # Error - too many arguments</snippet-file></snippet><heading level=\"2\">Adding default values</heading><paragraph>You can give parameters default values. If no argument is provided for that parameter then the function will use the default value.</paragraph><snippet line-numbers=\"true\" language=\"py\" runnable=\"true\"><snippet-file id=\"code\">def say_hello(name = &#39;James&#39;): # Give the parameter a default value\n&#x9;print(&#39;Hello,&#39;, name)\n\nsay_hello() # The default value will be used\nsay_hello(&#39;Sarah&#39;) # &#39;Sarah&#39; will be used instead</snippet-file></snippet><paragraph>You can use this feature to make arguments <italic>optional -</italic> Python won&#39;t raise an error if the argument is not supplied, it will just use the default value.</paragraph><paragraph>If you set the default value to <code>None</code> then you can use this to detect whether an argument was supplied for the parameter:</paragraph><snippet line-numbers=\"true\" language=\"py\" runnable=\"true\"><snippet-file id=\"code\">def say_hello(name = None):\n    if name is None:\n        print(&#39;No name was provided&#39;)\n    else:\n        print(&#39;Hello,&#39;, name)   \n\nsay_hello()\nsay_hello(&#39;Sarah&#39;)</snippet-file></snippet><heading level=\"2\">Returning values</heading><paragraph>A function always returns a value. By default it will return the object <code>None</code>, but you can use a <code>return</code> statement to get it to return whatever value you want.</paragraph><snippet language=\"py\" runnable=\"true\" line-numbers=\"true\"><snippet-file id=\"code\">def sum(x, y):\n    return x + y # Specify a return value\n\nprint(sum(1, 2))</snippet-file></snippet><paragraph>The function will exit immediately after a <code>return</code> statement, so any further statements in the function body will not be executed.</paragraph><snippet language=\"py\" runnable=\"true\" line-numbers=\"true\"><snippet-file id=\"code\">def sum(x, y):\n    return x + y # The function exits here\n    print(&#39;This will not be printed&#39;) # Not executed\n\nprint(sum(1, 2))</snippet-file></snippet><paragraph>You can have multiple <code>return</code> statements (but only one will get executed):</paragraph><snippet language=\"py\" runnable=\"true\" line-numbers=\"true\"><snippet-file id=\"code\">def grade(mark):\n    if mark &gt;= 50:\n        return &#39;Pass&#39;\n    else:\n        return &#39;Fail&#39; # Only one of these return statements will be executed\n\nprint(grade(73))\nprint(grade(35))</snippet-file></snippet><paragraph>A function can only return one value. This value can, however, be a collection - a list, or a tuple, or a set, or a dictionary. It is fairly common to return a tuple. Here&#39;s an example in which a tuple with two elements is returned:</paragraph><snippet language=\"py\" runnable=\"true\" line-numbers=\"true\"><snippet-file id=\"code\">def ends(string):\n    first_char = string[0]\n    last_char = string[-1]\n    # Return a tuple with two elements\n    # Note that only the comma is needed - round brackets are assumed\n    return first_char, last_char\n\nprint(ends(&#39;Australia&#39;))\nprint(ends(&#39;Australia&#39;)[0])\nprint(ends(&#39;Australia&#39;)[1])</snippet-file></snippet><paragraph>You might hear people describe this as a case in which the function returns two values. This is loose talk - the function returns just one value - a tuple. It&#39;s important to be aware of what&#39;s really going on here. </paragraph><heading level=\"2\">Supplying arguments by keyword</heading><paragraph>If your function has many parameters then it can be difficult to remember the order in which they need to be supplied when you call it, and it can be difficult for someone reading the code to tell which is which:</paragraph><snippet language=\"py\" runnable=\"true\" line-numbers=\"true\"><snippet-file id=\"code\">def divide(numerator, denominator, num_places):\n&#x9;return round(numerator/denominator, num_places)\n\n# Not clear to the reader which argument goes with which paramater\n# Which one is the numerator? Which is the denominator?\nprint(divide(5, 6, 3))</snippet-file></snippet><paragraph>To make things easier, arguments can be supplied by <bold>keyword</bold>:</paragraph><snippet line-numbers=\"true\" language=\"py\" runnable=\"true\"><snippet-file id=\"code\">def divide(numerator, denominator, num_places):\n&#x9;return round(numerator/denominator, num_places)\n\n# Now it&#39;s clear which argument goes with which paramater\nprint(divide(numerator=5, denominator=6, num_places=3))\n\n# And we don&#39;t have to worry about their order\nprint(divide(num_places=3, denominator=6, numerator=5)) # Same result</snippet-file></snippet><heading level=\"2\">Allowing an arbitrary number of arguments</heading><paragraph>Suppose you want a function that returns the smallest of some given numbers. Suppose you want to allow any number of numbers to be given.</paragraph><paragraph>One way would be to use a single parameter which expects a list. On this approach, you must provide exactly one argument, a list, but the list can be as long as you like:</paragraph><snippet line-numbers=\"true\" language=\"py\" runnable=\"true\"><snippet-file id=\"code\">def smallest(numbers): # Expects numbers to be a list\n    smallest = numbers[0]\n    for n in numbers:\n        if n &lt; smallest:\n            smallest = n\n    return smallest\n\nprint(smallest([42, 12])) # Provide a single list of 2 numbers\nprint(smallest([4, 11, 15, 2, 3])) # Provide a single list of 5 numbers</snippet-file></snippet><paragraph>Another way is to precede the name of the parameter with an asterisk. Then you can provide as many numbers as you like, not together in a single list, but each as a separate argument in its own right. The function will automatically combine them into a tuple:</paragraph><snippet language=\"py\" runnable=\"true\" line-numbers=\"true\"><snippet-file id=\"code\">def smallest(*numbers): # Add an asterisk to the front of the name\n    smallest = numbers[0]\n    for n in numbers:\n        if n &lt; smallest:\n            smallest = n\n    return smallest\n\nprint(smallest(42, 12)) # Provide 2 arguments\nprint(smallest(4, 11, 15, 2, 3)) # Provide 5 arguments</snippet-file></snippet><paragraph>You can also precede the name of the parameter with two asterisks. This allows you to provide as many keyword arguments as you like. This time they are gathered into a dictionary.</paragraph><snippet language=\"py\" runnable=\"true\" line-numbers=\"true\"><snippet-file id=\"code\">def full_name(**names):  # Add two asterisks to the front of the name\n    result = &#39;&#39;\n    if &#39;first&#39; in names: result = result + &#39; &#39; + names[&#39;first&#39;]\n    if &#39;middle&#39; in names: result = result + &#39; &#39; + names[&#39;middle&#39;]\n    if &#39;last&#39; in names: result = result + &#39; &#39; + names[&#39;last&#39;]\n    return result.strip()\n\nprint(full_name(first=&#39;John&#39;, last=&#39;Smith&#39;))\nprint(full_name(first=&#39;John&#39;, middle=&#39;Hubert&#39;, last=&#39;Smith&#39;))\nprint(full_name(last=&#39;Smith&#39;, middle=&#39;Hubert&#39;, first=&#39;John&#39;))</snippet-file></snippet><paragraph>You can use both kinds of parameter, but if you do then the * parameter must precede the ** parameter.</paragraph><heading level=\"2\">Pass</heading><paragraph>The body of a function definition cannot be empty, so if you want a function definition with no content then you need to use the pass statement to avoid Python raising an error. </paragraph><snippet language=\"py\" runnable=\"true\" line-numbers=\"true\"><snippet-file id=\"code\">def my_func():\n    return None</snippet-file></snippet><paragraph>Alternatively, you could put an expression in the body, such as <code>{}</code>, or get the function to return <code>None</code>, </paragraph><heading level=\"2\">Functions are given objects</heading><paragraph>It is important to be aware that when you pass an argument to a function, that function has direct access to the object and can change the object (if its mutable). Here&#39;s an example:</paragraph><snippet language=\"py\" runnable=\"true\" line-numbers=\"true\"><snippet-file id=\"code\">def add10(x):\n    x.append(10)\n\nlst = [1, 2, 3]\nadd10(lst)\nprint(lst)</snippet-file></snippet><paragraph>Notice that the function defined here changes the object that is passed to it as an argument. In this case we say that the function has <bold>side effects</bold> - it affects the state of the program outside the function.</paragraph><paragraph>One way to avoid the original list being changed is to use <bold>list</bold> method <code>copy()</code> as shown below:</paragraph><snippet language=\"py\" runnable=\"true\" line-numbers=\"true\"><snippet-file id=\"code\">def add10(x):\n    x.append(10)\n\nlst = [1, 2, 3]\nlst1 = lst.copy() # create a copy of the object\nadd10(lst1)\nprint(lst1)\nprint(lst) # will not be modified</snippet-file></snippet><paragraph>Please note that the above will not apply to parameters passed by <bold>value</bold> (instead of <bold>reference</bold> as the list example above) as shown below:</paragraph><snippet language=\"py\" runnable=\"true\" line-numbers=\"true\"><snippet-file id=\"code\">def add10(x):\n    x = x + 10\n    print(x) # outputs 15\n\nnum = 5\nadd10(num)\nprint(num) # outputs 5 NOT 15</snippet-file></snippet><paragraph></paragraph></document>"
    },
    {
      "id": 361962,
      "original_id": 340492,
      "lesson_id": 53307,
      "user_id": 93339,
      "course_id": 16645,
      "type": "document",
      "title": "Variable scope",
      "index": 159,
      "is_hidden": false,
      "lesson_markable_id": null,
      "rubric_id": null,
      "rubric_points": null,
      "auto_points": null,
      "status": "unseen",
      "correct": null,
      "response": null,
      "created_at": "2024-05-27T01:25:37.526309+10:00",
      "updated_at": null,
      "content": "<document version=\"2.0\"><paragraph>If you create a variable inside a function then that variable is only defined inside the function. We say that the variable&#39;s <bold>scope</bold> is limited to the function, or that the variable is <bold>locally defined</bold>. If you try to use a variable outside its scope then Python will raise an error.</paragraph><snippet language=\"py\" runnable=\"true\" line-numbers=\"true\"><snippet-file id=\"code\">def my_func():\n    x = 5\n\nprint(x) # Error - x is only defined inside the function</snippet-file></snippet><paragraph>Even if you have used the same variable name outside the function, changes to variables defined inside the function are limited to occurring inside the function.  This can be a problem if you use locally defined variables with the same name as globally defined variables (i.e. variables not declared within the scope of a function) - this is known as <bold>variable shadowing</bold>. </paragraph><snippet language=\"py\" runnable=\"true\" line-numbers=\"true\"><snippet-file id=\"code\">x = 3 # Globally defined x\n\ndef my_func():\n    x = 5 # Locally defined x, no change to the globally defined x\n\nmy_func() # No change to the globally defined x\nprint(x) # Prints 3, not 5</snippet-file></snippet><paragraph>If you want to use globally defined variables inside functions, the safest approach is to provide them to the function as arguments.</paragraph><snippet language=\"py\" runnable=\"true\" line-numbers=\"true\"><snippet-file id=\"code\">x = 3\n\ndef my_func(y):\n    return y + 2 # Add 2 to the number provided and return the result\n\nx = my_func(x) # Assign to x the result of of my_func(x) - changes x\nprint(x) # Prints 5</snippet-file></snippet><paragraph></paragraph></document>"
    },
    {
      "id": 361963,
      "original_id": 340494,
      "lesson_id": 53307,
      "user_id": 93339,
      "course_id": 16645,
      "type": "document",
      "title": "Nested functions",
      "index": 161,
      "is_hidden": false,
      "lesson_markable_id": null,
      "rubric_id": null,
      "rubric_points": null,
      "auto_points": null,
      "status": "unseen",
      "correct": null,
      "response": null,
      "created_at": "2024-05-27T01:25:37.526309+10:00",
      "updated_at": null,
      "content": "<document version=\"2.0\"><paragraph>You can define a function inside another function. When you do, the inside function is called a <bold>nested function</bold>. Here&#39;s an example:</paragraph><snippet language=\"py\" runnable=\"true\" line-numbers=\"true\"><snippet-file id=\"code\">def acronym(string):\n    result = &#39;&#39;\n    words = string.split(&#39; &#39;)\n    def upper_first(string): # A nested function\n        return string[0].upper()\n    for word in words:\n        result += upper_first(word)\n    return result\n    \nprint(acronym(&#39;World Health Organisation&#39;))</snippet-file></snippet><paragraph>Because a nested function is defined inside an enclosing function, it is only available to be called inside that enclosing function. The following program generates an error, because the nested function is called outside its enclosing function:</paragraph><snippet language=\"py\" runnable=\"true\" line-numbers=\"true\"><snippet-file id=\"code\">def acronym(string):\n    result = &#39;&#39;\n    words = string.split(&#39; &#39;)\n    def upper_first(string): # Only available inside acronym\n        return string[0].upper()\n    for word in words:\n        result += upper_first(word)\n    return result\n    \nprint(upper_first(&#39;hello&#39;)) # Error - upper_first is not available here</snippet-file></snippet></document>"
    },
    {
      "id": 361964,
      "original_id": 340495,
      "lesson_id": 53307,
      "user_id": 93339,
      "course_id": 16645,
      "type": "document",
      "title": "Lambda functions",
      "index": 162,
      "is_hidden": false,
      "lesson_markable_id": null,
      "rubric_id": null,
      "rubric_points": null,
      "auto_points": null,
      "status": "unseen",
      "correct": null,
      "response": null,
      "created_at": "2024-05-27T01:25:37.526309+10:00",
      "updated_at": null,
      "content": "<document version=\"2.0\"><paragraph>You can refer to a function without giving it a name.</paragraph><paragraph>Suppose, for example, you have a list of names and you want to sort those names by their <italic>last</italic> letter. You can use the list&#39;s <code>sort()</code> method to do this. By default, <code>sort()</code> sorts them alphabetically, but you can override this default by providing a function to use as the sorting key.</paragraph><paragraph>If you like, you can first define the function, giving it a name, and then provide it by name to <code>sort()</code>:</paragraph><snippet language=\"py\" runnable=\"true\" line-numbers=\"true\"><snippet-file id=\"code\">names = [&#39;Geoff&#39;, &#39;Kim&#39;, &#39;Louise&#39;, &#39;Tam&#39;, &#39;Helen&#39;]\ndef last_letter(name):\n    return name[-1]\nnames.sort(key = last_letter) # Use the function defined above\nprint(names)</snippet-file></snippet><paragraph>But you don&#39;t need to. You can refer to the function directly when you call <code>sort()</code>, without giving it a name. You do this by using a <bold>lambda function</bold>:</paragraph><snippet language=\"py\" runnable=\"true\" line-numbers=\"true\"><snippet-file id=\"code\">names = [&#39;Geoff&#39;, &#39;Kim&#39;, &#39;Louise&#39;, &#39;Tam&#39;, &#39;Helen&#39;]\nnames.sort(key = lambda name: name[-1]) # Use a lambda function\nprint(names)</snippet-file></snippet><paragraph>A lambda function is an <bold>expression</bold> (not a statement) whose value is a function. You can think of a lambda function as being a <bold>function literal</bold>.</paragraph><paragraph>The syntax of a lambda function is as follows:</paragraph><pre>lambda &lt;parameters&gt;: &lt;expression&gt;</pre><paragraph>Note that there is no <code>return</code> in a lambda function.</paragraph><paragraph>Lambda functions can have more than one parameter. Here&#39;s a lambda function with two parameters:</paragraph><snippet language=\"py\" runnable=\"true\" line-numbers=\"true\"><snippet-file id=\"code\">lambda a, b: a + b</snippet-file></snippet><paragraph>You can use a lambda function just like you use function names. You can call the function it refers to by using the usual round brackets notation (note that you typically need to put parentheses around the lambda function when you call it, to avoid confusion with neighbouring code):</paragraph><snippet language=\"py\" runnable=\"true\" line-numbers=\"true\"><snippet-file id=\"code\">print((lambda a, b: a + b)(2, 4))</snippet-file></snippet><paragraph>And you can use it to assign a value to a variable:</paragraph><snippet language=\"py\" runnable=\"true\" line-numbers=\"true\"><snippet-file id=\"code\">f = lambda a, b: a + b\nprint(f(2, 4))</snippet-file></snippet><paragraph>Note what is going on in this last example. We are using the lambda function <code>lambda a, b: a + b</code> to assign a value to a variable <code>f</code>. The value of the lambda function is a function - you can think of it as a literal for that function. So <code>f</code> is being assigned a function. We can then use <code>f</code> like any other function name. In line 2, we call the function, using <code>f(2, 4)</code>.</paragraph><paragraph>Compare the above with the following example:</paragraph><snippet language=\"py\" runnable=\"true\" line-numbers=\"true\"><snippet-file id=\"code\">def f(a, b):\n    return a + b\nprint(f(2, 4))</snippet-file></snippet><paragraph>The two examples are similar, but there are some subtle differences. In both examples we end up with <code>f</code> being the name of a function. But we get there in two different ways. In the first example, we <underline>assign</underline> <code>f</code> the function using an assignment statement and a lambda function that refers to the function. In the second example, we <underline>define</underline> <code>f</code> using a <code>def</code> statement that defines the function.</paragraph></document>"
    },
    {
      "id": 361965,
      "original_id": 340496,
      "lesson_id": 53307,
      "user_id": 93339,
      "course_id": 16645,
      "type": "document",
      "title": "Functions are objects",
      "index": 163,
      "is_hidden": false,
      "lesson_markable_id": null,
      "rubric_id": null,
      "rubric_points": null,
      "auto_points": null,
      "status": "unseen",
      "correct": null,
      "response": null,
      "created_at": "2024-05-27T01:25:37.526309+10:00",
      "updated_at": null,
      "content": "<document version=\"2.0\"><paragraph>Functions are objects, and you can use them in the same way you use other objects, such as numbers, strings, lists, and so on. Just as you might set a variable&#39;s value to a number, such as <code>1</code>, you might also set it to a function, such as <code>len()</code>. Also:</paragraph><list style=\"bullet\"><list-item><paragraph>You can assign a function to a variable</paragraph></list-item><list-item><paragraph>A function can be an attribute of an object</paragraph></list-item><list-item><paragraph>A function can be an element of a collection</paragraph></list-item><list-item><paragraph>Functions can be keys in a dictionary</paragraph></list-item><list-item><paragraph>You can pass a function as an argument of a function call</paragraph></list-item><list-item><paragraph>You can return a function as the result of a function call</paragraph></list-item></list><paragraph>And so on. Because of this we say that Python functions are <bold>first class</bold>.</paragraph><paragraph>Because you can supply functions as arguments to functions, you can create functions that operate on functions:</paragraph><snippet runnable=\"true\" line-numbers=\"true\" language=\"py\"><snippet-file id=\"code\">def add(x, y):\n&#x9;return x + y\ndef subtract(x, y):\n&#x9;return x - y\ndef apply(f, x, y): # This function applies function f to values x and y\n&#x9;return f(x, y)\n\nprint(apply(add, 10, 1))\nprint(apply(subtract, 10, 1))</snippet-file></snippet><paragraph>Here&#39;s another example. In this case we define a function <code>compose</code>, which takes two functions <code>f</code> and <code>g</code> as arguments and returns a function - the <italic>composition</italic> of <code>f</code> and <code>g</code>, which is the function that takes an argument <code>x</code> and returns <code>f(g(x))</code>:</paragraph><snippet language=\"py\" runnable=\"true\" line-numbers=\"true\"><snippet-file id=\"code\">def add1(x):\n&#x9;return x + 1\ndef subtract1(x):\n&#x9;return x - 1\ndef compose(f, g): # This function returns a function\n&#x9;return lambda x: f(g(x))\n\nadd2 = compose(add1, add1) # add2 is a new function\nprint(add2(10))\ndo_nothing = compose(add1, subtract1) # do_nothing is a new function\nprint(do_nothing(10))</snippet-file></snippet><paragraph>Functions that take functions as arguments, or return functions as values, are known as <bold>higher order functions</bold>.</paragraph><paragraph></paragraph></document>"
    },
    {
      "id": 361966,
      "original_id": 340497,
      "lesson_id": 53307,
      "user_id": 93339,
      "course_id": 16645,
      "type": "document",
      "title": "Generators",
      "index": 164,
      "is_hidden": false,
      "lesson_markable_id": null,
      "rubric_id": null,
      "rubric_points": null,
      "auto_points": null,
      "status": "unseen",
      "correct": null,
      "response": null,
      "created_at": "2024-05-27T01:25:37.526309+10:00",
      "updated_at": null,
      "content": "<document version=\"2.0\"><paragraph>Before we leave the topic of functions, there is one special type of function that you should know about.</paragraph><paragraph>Suppose you have a function that returns a collection of objects, perhaps a list. Suppose it is the following one:</paragraph><snippet line-numbers=\"true\" language=\"py\" runnable=\"true\"><snippet-file id=\"code\">def squares():\n    result = []\n    for x in range(10):\n        result.append(x**2)\n    return(result)\n\nprint(squares())</snippet-file></snippet><paragraph>The function returns the full list, which you can then <bold>iterate</bold> over:</paragraph><snippet line-numbers=\"true\" language=\"py\" runnable=\"true\"><snippet-file id=\"code\">def squares():\n    result = []\n    for x in range(10):\n        result.append(x**2)\n    return(result)\n\nfor x in squares():\n    print(x)</snippet-file></snippet><paragraph>Rather than getting the function to return the full list, you can get it to return the elements one at a time, by using a <code>yield</code> statement instead of a <code>return</code> statement:</paragraph><snippet language=\"py\" runnable=\"true\" line-numbers=\"true\"><snippet-file id=\"code\">def squares():\n    for x in range(10):\n        yield x**2 # Use a yield statement\n\nfor x in squares():\n    print(x)</snippet-file></snippet><paragraph>Notice what happens when you print:</paragraph><snippet language=\"py\" runnable=\"true\" line-numbers=\"true\"><snippet-file id=\"code\">def squares():\n    for x in range(10):\n        yield x**2\n\nprint(squares())</snippet-file></snippet><paragraph>The function now returns a special kind of object, called a <bold>generator</bold> - it does not return the full list. This generator object generates the elements as they are needed.</paragraph><paragraph>Why would you do this, rather than have the function return the full list at the outset? If the list is large, and if you don&#39;t need its elements all at once, then it is a good way to save memory. </paragraph><heading level=\"2\">Generator expressions</heading><paragraph>There is an even more concise way to make a generator. Rather than defining a function that returns a generator, you can use a <bold>generator expression</bold>. It is exactly like a comprehension, but you use round brackets. This is why there is no tuple comprehension - the round brackets are used for generator expressions instead.</paragraph><snippet language=\"py\" runnable=\"true\" line-numbers=\"true\"><snippet-file id=\"code\">squares = (x**2 for x in range(10)) # Get a generator from a generator expression\n\nprint(squares)\nfor x in squares:\n    print(x)</snippet-file></snippet><paragraph></paragraph></document>"
    },
    {
      "id": 361967,
      "original_id": 340498,
      "lesson_id": 53307,
      "user_id": 93339,
      "course_id": 16645,
      "type": "document",
      "title": "Further reading",
      "index": 165,
      "is_hidden": false,
      "lesson_markable_id": null,
      "rubric_id": null,
      "rubric_points": null,
      "auto_points": null,
      "status": "unseen",
      "correct": null,
      "response": null,
      "created_at": "2024-05-27T01:25:37.526309+10:00",
      "updated_at": null,
      "content": "<document version=\"2.0\"><paragraph>You might find the following helpful:</paragraph><list style=\"bullet\"><list-item><paragraph>The <link href=\"https://www.w3schools.com/python\">Python Tutorial</link> at w3schools.com</paragraph></list-item></list><paragraph></paragraph></document>"
    }
  ],
  "solutions_at": null,
  "state": "active",
  "status": "attempted",
  "submitted_at": null,
  "timer_duration": 60,
  "timer_effective_duration": 60,
  "timer_expiration_access": false,
  "title": "Week 3 - Functions",
  "tutorial_regex": "",
  "type": "general",
  "updated_at": null,
  "user_id": 93339
}