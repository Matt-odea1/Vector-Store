{
  "attempt_id": null,
  "attempted_at": null,
  "attempts": null,
  "attempts_remaining": null,
  "available_at": null,
  "clean_attempts": false,
  "course_id": 16645,
  "created_at": "2024-05-27T01:25:37.937984+10:00",
  "due_at": null,
  "effective_available_at": null,
  "effective_due_at": null,
  "effective_locked_at": null,
  "first_viewed_at": null,
  "grade_passback_auto_send": false,
  "grade_passback_mode": "",
  "grade_passback_scale_to": null,
  "id": 53311,
  "index": 7,
  "inverse_regex": false,
  "is_hidden": false,
  "is_timed": false,
  "is_unlisted": false,
  "kind": "content",
  "last_viewed_slide_id": null,
  "late_submissions": true,
  "locked_at": null,
  "module_id": 11528,
  "number": -1,
  "openable": false,
  "openable_without_attempt": false,
  "original_id": 47897,
  "outline": "",
  "password": "",
  "password_one_time": false,
  "prerequisites": [],
  "release_challenge_solutions": false,
  "release_challenge_solutions_while_active": false,
  "release_feedback": false,
  "release_feedback_while_active": false,
  "release_quiz_correctness_only": false,
  "release_quiz_solutions": false,
  "reopen_submissions": false,
  "require_user_override": false,
  "settings": {
    "quiz_question_number_style": "",
    "quiz_mode": "multiple-attempts",
    "quiz_active_status": "active"
  },
  "slide_count": 6,
  "slide_marks_summary": [
    {
      "id": 361977,
      "is_hidden": false,
      "rubric_points": 0,
      "auto_points": 0,
      "scoring_mode": "",
      "scale_to": null,
      "scale_to_auto": null,
      "scale_to_rubric": null
    },
    {
      "id": 361978,
      "is_hidden": false,
      "rubric_points": 0,
      "auto_points": 0,
      "scoring_mode": "",
      "scale_to": null,
      "scale_to_auto": null,
      "scale_to_rubric": null
    },
    {
      "id": 361979,
      "is_hidden": false,
      "rubric_points": 0,
      "auto_points": 0,
      "scoring_mode": "",
      "scale_to": null,
      "scale_to_auto": null,
      "scale_to_rubric": null
    },
    {
      "id": 361980,
      "is_hidden": false,
      "rubric_points": 0,
      "auto_points": 0,
      "scoring_mode": "",
      "scale_to": null,
      "scale_to_auto": null,
      "scale_to_rubric": null
    },
    {
      "id": 361981,
      "is_hidden": false,
      "rubric_points": 0,
      "auto_points": 0,
      "scoring_mode": "",
      "scale_to": null,
      "scale_to_auto": null,
      "scale_to_rubric": null
    },
    {
      "id": 361982,
      "is_hidden": false,
      "rubric_points": 0,
      "auto_points": 0,
      "scoring_mode": "",
      "scale_to": null,
      "scale_to_auto": null,
      "scale_to_rubric": null
    }
  ],
  "slides": [
    {
      "id": 361977,
      "original_id": 342266,
      "lesson_id": 53311,
      "user_id": 93339,
      "course_id": 16645,
      "type": "document",
      "title": "Creating modules",
      "index": 160,
      "is_hidden": false,
      "lesson_markable_id": null,
      "rubric_id": null,
      "rubric_points": null,
      "auto_points": null,
      "status": "unseen",
      "correct": null,
      "response": null,
      "created_at": "2024-05-27T01:25:37.937984+10:00",
      "updated_at": null,
      "content": "<document version=\"2.0\"><paragraph>You might find yourself creating your <bold>own</bold> <bold>functions</bold> or <bold>classes</bold> (to be discussed later) that you would like to use in various programs. Rather than copying and pasting their definitions into each program it is far better to put them into a <bold>module</bold>, and then import that module whenever you need to. Just as you can put <bold>code</bold> into <bold>functions</bold>, you can put <bold>functions</bold> (and <bold>classes</bold>) into <bold>modules</bold>.</paragraph><paragraph>You can create your own modules by writing Python code and saving it in a file with a \".py\" extension. Then you can import these modules into your code whenever you need them.</paragraph><paragraph>For example, suppose you have a module called \"<bold>hello.py</bold>\" which contains the following code:</paragraph><snippet language=\"py\" runnable=\"false\" line-numbers=\"true\"><snippet-file id=\"code\">def say_hello():\n    print('Hello world!')</snippet-file></snippet><paragraph>You can import and use this module just like any other module (<bold>do not include</bold> the \"<bold>.py</bold>\" part of the file name):</paragraph><snippet language=\"py\" runnable=\"false\" line-numbers=\"true\"><snippet-file id=\"code\">from hello import say_hello\nsay_hello()</snippet-file></snippet><heading level=\"2\">Importing quietly</heading><paragraph>Sometimes you might have code in your module that is <bold>outside</bold> of a function or class. For example, suppose the contents of \"hello.py\" are this:</paragraph><snippet language=\"py\" runnable=\"false\" line-numbers=\"true\"><snippet-file id=\"code\">def say_hello():\n    print('Hello world!')\nprint(\"Python is fun!\")</snippet-file></snippet><paragraph>When you import this module into your program, the Python interpreter executes the code in the module, including line 3. This will generate output in your program that you probably don't want:</paragraph><pre>Python is fun!\nHello world!\n</pre><paragraph><code>Python is fun!</code> is a consequence of line 3 of your module, which was executed when it was imported.</paragraph><paragraph>It is better if your module is <bold>imported</bold> <bold>quietly</bold>. You make sure this happens by modifying your module as follows:</paragraph><snippet language=\"py\" runnable=\"false\" line-numbers=\"true\"><snippet-file id=\"code\">def say_hello():\n    print('Hello world!')\n\nif __name__ == '__main__':\n    print(\"Python is fun!\")</snippet-file></snippet><paragraph>When a file executes it contains is a special variable <code>__name__</code> that indicates whether the file has been <bold>executed</bold> as a <bold>standalone file</bold> or as an <bold>imported module</bold>. In the former case, the value of this variable is <code>'__main__'</code>, otherwise it is the name of the module, <code>'hello'</code>. This gives you a way of checking whether your module was executed as a standalone file or as an imported module, and modifying its behaviour accordingly. In the code above, line 4 does the check, and <code>print(\"Python is fun!\")</code> is considered only if the module is being executed as a standalone file. When you import the module, it will not be executed.</paragraph></document>"
    },
    {
      "id": 361978,
      "original_id": 342268,
      "lesson_id": 53311,
      "user_id": 93339,
      "course_id": 16645,
      "type": "code",
      "title": "Modules Example",
      "index": 161,
      "is_hidden": false,
      "lesson_markable_id": null,
      "rubric_id": null,
      "rubric_points": null,
      "auto_points": null,
      "status": "unseen",
      "correct": null,
      "response": null,
      "created_at": "2024-05-27T01:25:37.937984+10:00",
      "updated_at": null,
      "challenge_id": 119328,
      "content": ""
    },
    {
      "id": 361979,
      "original_id": 342264,
      "lesson_id": 53311,
      "user_id": 93339,
      "course_id": 16645,
      "type": "document",
      "title": "Recursion",
      "index": 162,
      "is_hidden": false,
      "lesson_markable_id": null,
      "rubric_id": null,
      "rubric_points": null,
      "auto_points": null,
      "status": "unseen",
      "correct": null,
      "response": null,
      "created_at": "2024-05-27T01:25:37.937984+10:00",
      "updated_at": null,
      "content": "<document version=\"2.0\"><paragraph>You can get a function to <bold>call itself</bold>. This is a very powerful technique known as <bold>recursion</bold>. A function that calls itself is said to be a <bold>recursive function</bold>.</paragraph><paragraph>Suppose you want to create a function that calculates, for a given number n, the <bold>factorial</bold> of n, which is 1 × 2 × 3 × ... × n.</paragraph><paragraph>For example, the factorial of 6 is 1 × 2 × 3 × 4 × 5 × 6 = 720.</paragraph><paragraph>You can do this <bold>without</bold> recursion, using a loop: </paragraph><snippet language=\"py\" runnable=\"true\" line-numbers=\"true\"><snippet-file id=\"code\">def factorial(n):\n\tresult = 1\n\tfor x in range(1, n+1):\n\t\tresult = result * x\n\treturn result\n\nnumber = input('Enter a number: ')\nnumber = int(number)\nprint(f'The factorial of {number} is {factorial(number)}.')</snippet-file></snippet><paragraph>Alternatively, you can do it with <bold>recursion</bold>.</paragraph><paragraph>The trick is to notice that the <bold>factorial of n</bold> can be obtained by multiplying <bold>n</bold> by the <bold>factorial of (n-1)</bold>.</paragraph><paragraph>Hence, we can do this:</paragraph><snippet language=\"py\" runnable=\"true\" line-numbers=\"true\"><snippet-file id=\"code\">def factorial(n):\n    if n== 0 or n == 1:\n        return 1\n    else:\n        return n * factorial(n-1) # Recursion - the function calls itself\n\nnumber = input('Enter a number: ')\nnumber = int(number)\nprint(f'The factorial of {number} is {factorial(number)}.')</snippet-file></snippet><paragraph>You need to be careful, when defining a recursive function, that it does not keep calling itself forever. That is why the recursive function above checks the value of n and decides what to do accordingly. There are two cases:</paragraph><list style=\"bullet\"><list-item><paragraph><underline><bold>n = 1</bold></underline>. If n is 1 then the function doesn't call itself - it just returns 1. This is sometimes called the <bold>base case</bold>.</paragraph></list-item><list-item><paragraph><underline><bold>Otherwise</bold></underline>. If n is not 1 then the function calls itself. This is sometimes called the <bold>recursive case</bold>.</paragraph></list-item></list><paragraph>The <bold>base case</bold> is important - it stops the function from calling itself forever. Notice what happens without it:</paragraph><snippet language=\"py\" runnable=\"true\" line-numbers=\"true\"><snippet-file id=\"code\">def factorial(n):\n    return n * factorial(n-1)\n\nnumber = input('Enter a number: ')\nnumber = int(number)\nprint(f'The factorial of {number} is {factorial(number)}.')</snippet-file></snippet><paragraph>It is very common for a recursive function to distinguish these two cases - the base case and the recursive case. When you define a recursive function, check that you have your cases covered. </paragraph></document>"
    },
    {
      "id": 361980,
      "original_id": 342265,
      "lesson_id": 53311,
      "user_id": 93339,
      "course_id": 16645,
      "type": "document",
      "title": "More Recursive Examples",
      "index": 163,
      "is_hidden": false,
      "lesson_markable_id": null,
      "rubric_id": null,
      "rubric_points": null,
      "auto_points": null,
      "status": "unseen",
      "correct": null,
      "response": null,
      "created_at": "2024-05-27T01:25:37.937984+10:00",
      "updated_at": null,
      "content": "<document version=\"2.0\"><heading level=\"2\">Adding Two Numbers</heading><snippet runnable=\"true\" line-numbers=\"true\" language=\"py\"><snippet-file id=\"code\">def add(a,b):\n&#x9;if b == 0:\n&#x9;&#x9;return a\n&#x9;return add(a,b-1) + 1\n&#x9;\nprint(add(4,9))</snippet-file></snippet><paragraph></paragraph><heading level=\"2\">Multiply by 4</heading><snippet language=\"py\" runnable=\"true\" line-numbers=\"true\"><snippet-file id=\"code\">def mult4(n):\n&#x9;if n == 1:\n&#x9;&#x9;return 4\n&#x9;return mult4(n-1) + 4\n&#x9;\nprint(mult4(1))\nprint(mult4(5))</snippet-file></snippet><paragraph></paragraph><heading level=\"2\">Factorial - Better Version</heading><snippet runnable=\"true\" line-numbers=\"true\" language=\"py\"><snippet-file id=\"code\">def fact(n):\n    if n &lt;= 1:\n        return 1\n    return n*fact(n-1)\nprint(fact(0))\nprint(fact(1))\nprint(fact(4))\n\ndef facti(n):\n    res = 1\n    for i in range(2,n+1):\n        res*=i\n    return res\nprint(facti(0))\nprint(facti(1))\nprint(facti(4))</snippet-file></snippet><paragraph></paragraph></document>"
    },
    {
      "id": 361981,
      "original_id": 342267,
      "lesson_id": 53311,
      "user_id": 93339,
      "course_id": 16645,
      "type": "code",
      "title": "Fibonacci Iterative, Recursive, and Memoise Versions",
      "index": 164,
      "is_hidden": false,
      "lesson_markable_id": null,
      "rubric_id": null,
      "rubric_points": null,
      "auto_points": null,
      "status": "unseen",
      "correct": null,
      "response": null,
      "created_at": "2024-05-27T01:25:37.937984+10:00",
      "updated_at": null,
      "challenge_id": 119329,
      "content": ""
    },
    {
      "id": 361982,
      "original_id": 326140,
      "lesson_id": 53311,
      "user_id": 93339,
      "course_id": 16645,
      "type": "document",
      "title": "Further reading",
      "index": 165,
      "is_hidden": false,
      "lesson_markable_id": null,
      "rubric_id": null,
      "rubric_points": null,
      "auto_points": null,
      "status": "unseen",
      "correct": null,
      "response": null,
      "created_at": "2024-05-27T01:25:37.937984+10:00",
      "updated_at": null,
      "content": "<document version=\"2.0\"><paragraph>You might find the following helpful:</paragraph><list style=\"bullet\"><list-item><paragraph>The <link href=\"https://www.w3schools.com/python\">Python Tutorial</link> at w3schools.com</paragraph></list-item></list><paragraph></paragraph></document>"
    }
  ],
  "solutions_at": null,
  "state": "active",
  "status": "unattempted",
  "submitted_at": null,
  "timer_duration": 60,
  "timer_effective_duration": 60,
  "timer_expiration_access": false,
  "title": "Week 4 - Modules and Recursion",
  "tutorial_regex": "",
  "type": "general",
  "updated_at": null,
  "user_id": 93339
}